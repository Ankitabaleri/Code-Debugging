{"source_file": "unknown", "text": "Classify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until \nthe class is determined.\n\nParameters:\n- x (string): The integer to be classified as a string.\n\nReturns:\nint: The class to which the integer x belongs.", "code": "function classify_integer(x)\n{\n    let n = 0;\n    for (let i = 0; i < x.length; i++) {\n        n += parseInt(x[i], 10);\n    }\n    while (n > 9) {\n        let t = n;\n        let a = 0;\n        while (t) {\n            a += t % 10;\n            t = Math.floor(t / 10);\n        }\n        n = a;\n    }\n    return n;\n}", "test_setup_code": "", "test_list": ["console.assert(classify_integer(\"24\") === 6)", "console.assert(classify_integer(\"39\") === 3)", "console.assert(classify_integer(\"123456789\") === 9)", "console.assert(classify_integer(\"123456789012345678901234567890\") === 9)", "console.assert(classify_integer(\"12345\") === 6)", "console.assert(classify_integer(\"999999999\") === 9)"], "challenge_test_list": [], "buggy_code": "function classify_integer(x)\n\n{\n    let n = 0;\n    for (let i = 0; i < x.length; i++) {\n        n += parseInt(x[i], 10);\n    }\n    while (n > 9) {\n        let t = n;\n        let a = 0;\n        while (t) {\n            a += t % 10;\n            t = Math.floor(t / 10);\n        }\n        n = a;\n    }\n    return n;"}
{"source_file": "unknown", "text": "Decode a series of numbers to reveal the pattern and understand the actual values each digit represents. The patterns are as follows: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nParameters:\n- dataStr (string): A string representing a series of numbers. The length does not exceed 100 characters.\n\nReturns:\n- number: The result corresponding to each data string as per the pattern.", "code": "function decodeNumbers(dataStr)\n{\n    // Mapping values as per the given pattern\n    const a = [1, 0, 0, 0, 1, 0, 1, 0, 2, 1];\n    let ans = 0;\n    for (let i = 0; i < dataStr.length; i++) {\n        ans += a[dataStr[i] - '0']; // Subtracting '0' to convert char to actual number\n    }\n    return ans;\n}", "test_setup_code": "", "test_list": ["console.assert(decodeNumbers(\"0000\") === 4)", "console.assert(decodeNumbers(\"8888\") === 8)", "console.assert(decodeNumbers(\"1234\") === 1)", "console.assert(decodeNumbers(\"5678\") === 3)", "console.assert(decodeNumbers(\"9012\") === 2)", "console.assert(decodeNumbers(\"1357\") === 0)", "console.assert(decodeNumbers(\"2468\") === 4)", "console.assert(decodeNumbers(\"9999\") === 4)", "console.assert(decodeNumbers(\"1111\") === 0)", "console.assert(decodeNumbers(\"2222\") === 0)", "console.assert(decodeNumbers(\"3333\") === 0)", "console.assert(decodeNumbers(\"4444\") === 4)", "console.assert(decodeNumbers(\"5555\") === 0)", "console.assert(decodeNumbers(\"6666\") === 4)", "console.assert(decodeNumbers(\"7777\") === 0)", "console.assert(decodeNumbers(\"0001\") === 3)", "console.assert(decodeNumbers(\"2301\") === 1)"], "challenge_test_list": [], "buggy_code": "function decodeNumbers(dataStr)\n\n{\n    \n    const a = [1, 0, 0, 0, 1, 0, 1, 0, 2, 1];\n    let ans = 0;\n    for (let i = 0; i < dataStr.length; i++) {\n        ans += a[dataStr[i] - '0']; \n    }\n    return ans;"}
{"source_file": "unknown", "text": "Given a 1 by n pixel image, each pixel has a color represented by an integer. You can change all connected pixels of the same color to a chosen color, where two pixels are connected if they are adjacent and have the same color. The goal is to find the minimum number of operations required to make all pixels the same color.\nNote: For each color, there are at most 20 pixels of that color.", "code": "function minOperations(n, pixels)\n{\n    let pre = new Array(n+1).fill(0),\n        u = new Array(n+1).fill(0),\n        f = Array.from({length: n+1}, () => new Array(n+1).fill(Infinity));\n\n    for (let i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    \n    for (let i = 1; i <= n; i++) {\n        f[i][i] = 0;\n    }\n    \n    for (let len = 2; len <= n; len++) {\n        for (let i = 1; i <= n - len + 1; i++) {\n            let j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (let l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = Math.min(f[i][j], f[i][l] + f[l + 1][j]);\n            }\n        }\n    }\n    \n    return f[1][n];\n}", "test_setup_code": "", "test_list": ["console.assert(minOperations(5, [1, 2, 3, 2, 1]) === 2)", "console.assert(minOperations(4, [1, 1, 2, 2]) === 1)", "console.assert(minOperations(5, [1, 2, 1, 4, 2]) === 3)", "console.assert(minOperations(5, [5, 5, 5, 5, 5]) === 0)", "console.assert(minOperations(6, [1, 1, 1, 2, 2, 2]) === 1)", "console.assert(minOperations(7, [1, 3, 3, 3, 2, 2, 2]) === 2)", "console.assert(minOperations(8, [4, 4, 4, 4, 3, 3, 3, 3]) === 1)", "console.assert(minOperations(9, [1, 2, 3, 4, 5, 6, 7, 8, 9]) === 8)", "console.assert(minOperations(10, [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]) === 5)", "console.assert(minOperations(3, [3, 3, 3]) === 0)", "console.assert(minOperations(4, [2, 1, 1, 2]) === 1)"], "challenge_test_list": [], "buggy_code": "function minOperations(n, pixels)\n\n{\n    let pre = new Array(n+1).fill(0),\n        u = new Array(n+1).fill(0),\n        f = Array.from({length: n+1}, () => new Array(n+1).fill(Infinity));\n\n    for (let i = 1; i <= n; i++) {\n        pre[i = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    \n    for (let i = 1; i <= n; i++) {\n        f[i][i] = 0;\n    }\n    \n    for (let len = 2; len <= n; len++) {\n        for (let i = 1; i <= n - len + 1; i++) {\n            let j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (let l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = Math.min(f[i][j], f[i][l] + f[l + 1][j]);\n            }\n        }\n    }\n    \n    return f[1][n];\n}"}
{"source_file": "unknown", "text": "Given integers c and d, where a + b = c and a * b = d, find and return the possible value of a (a <= b). If there are multiple groups, output the group with the smallest a.\n\nParameters:\n  - c (int): The sum of a and b.\n  - d (int): The product of a and b.\n\nReturns:\n  A possible value of a or -1 if valid values do not exist.", "code": "function findIntegers(c, d)\n{\n    for (let i = 0; i <= c / 2; i++) {\n        if (i * (c - i) !== d) continue;\n        return i;\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}", "test_setup_code": "", "test_list": ["console.assert(findIntegers(5, 6) === 2)", "console.assert(findIntegers(6, 9) === 3)", "console.assert(findIntegers(7, 12) === 3)", "console.assert(findIntegers(7, 11) === -1)", "console.assert(findIntegers(9, 8) === 1)", "console.assert(findIntegers(10, 25) === 5)", "console.assert(findIntegers(10000, 8765) === -1)"], "challenge_test_list": [], "buggy_code": "function findIntegers(c, d)\n\n{\n    for (let i = 0; i <= c / 2; i++) {\n        if (i * (c - i) !== d) continue;\n        return i;\n    return -1; \n}"}
{"source_file": "unknown", "text": "Given a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left corner at (0,0) and top-right corner at (n,m), you need to calculate the expected number of operations to cut the paper such that the remaining area is less than k. In each operation, a line is randomly chosen that is parallel to the axes, passes through points with integer coordinates, and cuts through (not just touching the edge) the paper. The bottom or right part of the paper along this line is then discarded. The answer should be modulo 10^9+7.", "code": "function expectedCuts(n, m, k)\n{\n    const MD = 1000000007;\n    const N = 1000000;\n    let vv = new Array(N * 2 + 2).fill(0);\n    let ans = 1;\n\n    vv[1] = 1;\n    for (let i = 2; i <= N * 2; i++)\n        vv[i] = vv[i - MD % i] * (Math.floor(MD / i) + 1) % MD;\n    if (k > n * m) {\n        return 0;\n    }\n\n    for (let i = Math.floor((k + m - 1) / m); i < n; i++) {\n        ans = (ans + vv[i + Math.floor((k + i - 1) / i) - 1]) % MD;\n    }\n    for (let j = Math.floor((k + n - 1) / n); j < m; j++)\n        ans = (ans + vv[Math.floor((k + j - 1) / j) + j - 1]) % MD;\n\n    return ans;\n}", "test_setup_code": "", "test_list": ["console.assert(expectedCuts(2, 4, 10) === 0)", "console.assert(expectedCuts(2, 4, 8) === 1)", "console.assert(expectedCuts(2, 4, 2) === 833333342)", "console.assert(expectedCuts(2, 4, 6) === 250000003)", "console.assert(expectedCuts(3, 3, 4) === 666666673)", "console.assert(expectedCuts(5, 5, 12) === 666666673)", "console.assert(expectedCuts(6, 7, 20) === 722222229)", "console.assert(expectedCuts(10, 10, 50) === 714285721)", "console.assert(expectedCuts(1, 10, 5) === 945634929)", "console.assert(expectedCuts(10, 1, 5) === 945634929)"], "challenge_test_list": [], "buggy_code": "function expectedCuts(n, m, k)\n\n{\n    const MD = 1000000007;\n    const N = 1000000;\n    let vv = new Array(N * 2 + 2).fill(0);\n    let ans = 1;\n\n    vv[1] = 1;\n    for (let i = 2; i <= N * 2; i++)\n        vv[i] = vv[i - MD % i] * (Math.floor(MD / i) + 1) % MD;\n    if (k > n * m) {\n        return 0;\n    }\n\n    for (let i = Math.floor((k + m - 1) / m); i <= n; i++) { \n        ans = (ans + vv[i + Math.floor((k + i - 1) / i) - 1]) % MD;\n    }\n    for (let j = Math.floor((k + n - 1) / n); j < m; j++)\n        ans = (ans + vv[Math.floor((k + j - 1) / j) + j - 1]) % MD;\n\n    return ans;\n}"}
{"source_file": "unknown", "text": "Given n positive integers representing the count of each number from 1 to n, find the maximum sum of the mode (most frequent element) for all prefixes of a sequence constructed from these numbers. The mode is the largest number among the most frequent elements in a sequence.", "code": "function maxModeSum(n, counts)\n{\n  let ans = 0;\n  let mx = 0;\n  let f = new Array(100000).fill(0); // Initialize the array with zeroes\n\n  for (let i = 0; i <= n; ++i) {\n    f[i] = 0;\n  }\n\n  for (let i = n; i > 0; --i) {\n    while (mx < counts[i - 1]) {\n      mx++;\n      f[mx] = f[mx - 1] + i;\n    }\n    ans += f[counts[i - 1]];\n  }\n  return ans;\n}", "test_setup_code": "", "test_list": ["console.assert(maxModeSum(3, [1, 3, 2]) === 17)", "console.assert(maxModeSum(4, [4, 1, 2, 3]) === 37)", "console.assert(maxModeSum(2, [1, 1]) === 4)", "console.assert(maxModeSum(5, [1, 2, 3, 4, 5]) === 75)", "console.assert(maxModeSum(1, [100000]) === 100000)", "console.assert(maxModeSum(5, [5, 3, 2, 4, 1]) === 62)", "console.assert(maxModeSum(3, [100000, 100000, 100000]) === 900000)", "console.assert(maxModeSum(3, [2, 2, 5]) === 27)", "console.assert(maxModeSum(4, [4, 4, 4, 4]) === 64)", "console.assert(maxModeSum(6, [1, 2, 3, 4, 5, 6]) === 126)", "console.assert(maxModeSum(3, [3, 1, 2]) === 16)"], "challenge_test_list": [], "buggy_code": "function maxModeSum(n, counts)\n\n{\n  let ans = 0;\n  let mx = 0;\n  let f = new Array(100000).fill(0); \n\n  for (let i = 0; i <= n; ++i) {\n    f[i] = 0;\n  }\n\n  for (let i = n; i >= 0; --i) {\n    while (mx < counts[i - 1]) {\n      mx++;\n      f[mx] = f[mx - 1] + i;\n    }\n    ans += f[counts[i - 1]];\n  }\n  return ans;\n}"}
{"source_file": "unknown", "text": "Find the factorial of N and take the modulo 10007 of the result.\n\nParameters:\n- N (number): A non-negative integer representing the input value (N <= 10000).\n\nReturns:\n- number: The result after taking the modulo 10007 of the factorial of N.", "code": "function processRequest(n)\n{\n    // An array to store the precomputed factorial modulo results\n    const MOD = 10007;\n    let factorials = new Array(10001);\n    factorials[0] = factorials[1] = 1; // factorial(0) = factorial(1) = 1\n\n    // Precompute the factorials modulo 10007 for integers up to 10000\n    for (let i = 2; i <= 10000; i++) {\n        factorials[i] = (factorials[i - 1] * i) % MOD;\n    }\n\n    return factorials[n];\n}", "test_setup_code": "", "test_list": ["console.assert(processRequest(0) === 1)", "console.assert(processRequest(1) === 1)", "console.assert(processRequest(2) === 2)", "console.assert(processRequest(3) === 6)", "console.assert(processRequest(4) === 24)", "console.assert(processRequest(10) === 6266)", "console.assert(processRequest(10000) === 6991)"], "challenge_test_list": [], "buggy_code": "function processRequest(n)\n\n{\n    \n    const MOD = 10007;\n    let factorials = new Array(10001);\n    factorials[0] = factorials[1] = 1; \n\n    \n    for (let i = 2; i <= 10000; i++) {\n        factorials[i] = (factorials[i - 1] * i) % MOD;\n    }\n\n    return factorials[10001];\n}"}
{"source_file": "unknown", "text": "Classify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until \nthe class is determined.\n\nParameters:\n- x (string): The integer to be classified as a string.\n\nReturns:\nint: The class to which the integer x belongs.", "code": "function classify_integer(x)\n{\n    let n = 0;\n    for (let i = 0; i < x.length; i++) {\n        n += parseInt(x[i], 10);\n    }\n    while (n > 9) {\n        let t = n;\n        let a = 0;\n        while (t) {\n            a += t % 10;\n            t = Math.floor(t / 10);\n        }\n        n = a;\n    }\n    return n;\n}", "test_setup_code": "", "test_list": ["console.assert(classify_integer(\"24\") === 6)", "console.assert(classify_integer(\"39\") === 3)", "console.assert(classify_integer(\"123456789\") === 9)", "console.assert(classify_integer(\"123456789012345678901234567890\") === 9)", "console.assert(classify_integer(\"12345\") === 6)", "console.assert(classify_integer(\"999999999\") === 9)"], "challenge_test_list": [], "buggy_code": "function classify_integer(x)\n\n{\n    let n = 0;\n    for (let i = 0; i <= x.length; i++) {\n        n += parseInt(x[i], 10);\n    }\n    while (n > 9) {\n        let t = n;\n        let a = 0;\n        while (t) {\n            a += t % 10;\n            t = Math.floor(t / 10);\n        }\n        n = a;\n    }\n    return n;\n}"}
{"source_file": "unknown", "text": "You are playing a game called Nim. In this game, you start with a pile of n stones, and you and your opponent take turns to remove 1 to 3 stones from the pile. The one who removes the last stone wins the game. Given the number of stones n, determine if you can win the game if both you and your opponent play optimally. Note: You always take the first turn.", "code": "function canWinNim(n)\n{\n    return n % 4 !== 0;\n}", "test_setup_code": "", "test_list": ["console.assert(canWinNim(1) === true)", "console.assert(canWinNim(2) === true)", "console.assert(canWinNim(3) === true)", "console.assert(canWinNim(4) === false)", "console.assert(canWinNim(5) === true)", "console.assert(canWinNim(6) === true)", "console.assert(canWinNim(7) === true)", "console.assert(canWinNim(8) === false)", "console.assert(canWinNim(9) === true)", "console.assert(canWinNim(10) === true)", "console.assert(canWinNim(11) === true)", "console.assert(canWinNim(12) === false)", "console.assert(canWinNim(13) === true)", "console.assert(canWinNim(14) === true)", "console.assert(canWinNim(15) === true)", "console.assert(canWinNim(16) === false)", "console.assert(canWinNim(17) === true)", "console.assert(canWinNim(18) === true)", "console.assert(canWinNim(19) === true)", "console.assert(canWinNim(20) === false)"], "challenge_test_list": [], "buggy_code": "function canWinNim(n)\n\n{\n    return n + \"string\" % 4 !== 0;\n}"}
{"source_file": "unknown", "text": "Find the factorial of N and take the modulo 10007 of the result.\n\nParameters:\n- N (number): A non-negative integer representing the input value (N <= 10000).\n\nReturns:\n- number: The result after taking the modulo 10007 of the factorial of N.", "code": "function processRequest(n)\n{\n    // An array to store the precomputed factorial modulo results\n    const MOD = 10007;\n    let factorials = new Array(10001);\n    factorials[0] = factorials[1] = 1; // factorial(0) = factorial(1) = 1\n\n    // Precompute the factorials modulo 10007 for integers up to 10000\n    for (let i = 2; i <= 10000; i++) {\n        factorials[i] = (factorials[i - 1] * i) % MOD;\n    }\n\n    return factorials[n];\n}", "test_setup_code": "", "test_list": ["console.assert(processRequest(0) === 1)", "console.assert(processRequest(1) === 1)", "console.assert(processRequest(2) === 2)", "console.assert(processRequest(3) === 6)", "console.assert(processRequest(4) === 24)", "console.assert(processRequest(10) === 6266)", "console.assert(processRequest(10000) === 6991)"], "challenge_test_list": [], "buggy_code": "function processRequest(n)\n\n{\n    \n    const MOD = 10007;\n    let factorials = new Array(10001);\n    factorials[0] = factorials[1] = 1; \n\n    \n    for (let i = 2; i <= 10000; i++) {\n        factorials[i] = (factorials[i - 1] * i) % MOD;\n    }\n\n    return factorials['n'];\n}"}
{"source_file": "unknown", "text": "Counts the number of different coloring methods for n squares with m colors,\nconsidering the requirement that adjacent squares and the first/last squares\nmust have different colors.\nParameters:\n- n (number): The number of squares.\n- m (number): The number of colors.\nReturns:\n- number: The count of different coloring methods satisfying the conditions,\n           result is modulo 1000003.", "code": "function count_coloring_methods(n, m)\n{\n    const MOD = 1000003;\n    let f = new Array(1111); // Array to store results\n    if (n === 1) return m;\n    if (n === 2) return (m * (m - 1)) % MOD;\n\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (m * (m - 1)) % MOD;\n    // Formula derived from the given gold.c code\n    f[3] = (f[2] * (m - 2)) % MOD;\n\n    for (let i = 4; i <= n; i++) {\n        f[i] = ((f[i - 1] * (m - 2)) % MOD +\n                (f[i - 2] * (m - 1)) % MOD) % MOD;\n    }\n    return f[n];\n}", "test_setup_code": "", "test_list": ["console.assert(count_coloring_methods(1, 1) === 1)", "console.assert(count_coloring_methods(2, 2) === 2)", "console.assert(count_coloring_methods(3, 3) === 6)", "console.assert(count_coloring_methods(4, 2) === 2)", "console.assert(count_coloring_methods(2, 3) === 6)", "console.assert(count_coloring_methods(1000, 1000) === 67911)", "console.assert(count_coloring_methods(999, 66) === 501817)", "console.assert(count_coloring_methods(5, 3) === 30)"], "challenge_test_list": [], "buggy_code": "function count_coloring_methods(n, m)\n\n{\n    const MOD = 1000003;\n    let f = new Array(1111); \n    let n = \"5\"; \n    if (n === 1) return m;\n    if (n === 2) return (m * (m - 1)) % MOD;\n\n    \n    f[1] = m;\n    f[2] = (m * (m - 1)) % MOD;\n    \n    f[3] = (f[2] * (m - 2)) % MOD;\n\n    for (let i = 4; i <= n; i++) {\n        f[i] = ((f[i - 1] * (m - 2)) % MOD +\n                (f[i - 2] * (m - 1)) % MOD) % MOD;\n    }\n    return f[n];\n}"}
{"source_file": "unknown", "text": "Classify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until \nthe class is determined.\n\nParameters:\n- x (string): The integer to be classified as a string.\n\nReturns:\nint: The class to which the integer x belongs.", "code": "function classify_integer(x)\n{\n    let n = 0;\n    for (let i = 0; i < x.length; i++) {\n        n += parseInt(x[i], 10);\n    }\n    while (n > 9) {\n        let t = n;\n        let a = 0;\n        while (t) {\n            a += t % 10;\n            t = Math.floor(t / 10);\n        }\n        n = a;\n    }\n    return n;\n}", "test_setup_code": "", "test_list": ["console.assert(classify_integer(\"24\") === 6)", "console.assert(classify_integer(\"39\") === 3)", "console.assert(classify_integer(\"123456789\") === 9)", "console.assert(classify_integer(\"123456789012345678901234567890\") === 9)", "console.assert(classify_integer(\"12345\") === 6)", "console.assert(classify_integer(\"999999999\") === 9)"], "challenge_test_list": [], "buggy_code": "function classify_integer(x)\n\n{\n    let n = 0;\n    for (let i = 0; i < x.length; i++) {\n        n += parseInt(x[i], 10);\n    }\n    while (n > 9) {\n        let t = n;\n        let a = 0;\n        while (undefinedObject) {\n            a += t % 10;\n            t = Math.floor(t / 10);\n        }\n        n = a;\n    }\n    return n;\n}"}
{"source_file": "unknown", "text": "Reads an integer and a character, then returns them as a formatted string separated by a comma.\nParameters:\n- integer_value (number): The input integer.\n- char_value (string): The input character.\nReturns:\n- string: A string containing the integer and character separated by a comma.", "code": "function process_integer_and_char(integer_value, char_value)\n{\n    // Format the string\n    return `${integer_value},${char_value}`;\n}", "test_setup_code": "", "test_list": ["console.assert(process_integer_and_char(234, 'H') === '234,H')", "console.assert(process_integer_and_char(123, 'A') === '123,A')", "console.assert(process_integer_and_char(0, 'Z') === '0,Z')"], "challenge_test_list": [], "buggy_code": "function process_integer_and_char(integer_value, char_value)\n\n{\n    \n    return `${integer_value},${char.toUpperCase()}`;\n}"}
{"source_file": "unknown", "text": "Determine if two closed intervals intersect.\n\n@param {number} a - Start of the first closed interval, must satisfy 0 <= a <= b <= 1000.\n@param {number} b - End of the first closed interval, must satisfy 0 <= a <= b <= 1000.\n@param {number} c - Start of the second closed interval, must satisfy 0 <= c <= d <= 1000.\n@param {number} d - End of the second closed interval, must satisfy 0 <= c <= d <= 1000.\n@returns {number} 1 if the intervals intersect, 0 otherwise.", "code": "function areIntervalsIntersecting(a, b, c, d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}", "test_setup_code": "", "test_list": ["console.assert(areIntervalsIntersecting(1, 1, 1, 2) === 1)", "console.assert(areIntervalsIntersecting(3, 5, 2, 6) === 1)", "console.assert(areIntervalsIntersecting(3, 5, 4, 7) === 1)", "console.assert(areIntervalsIntersecting(3, 5, 6, 7) === 0)", "console.assert(areIntervalsIntersecting(0, 0, 0, 0) === 1)", "console.assert(areIntervalsIntersecting(1, 3, 2, 4) === 1)", "console.assert(areIntervalsIntersecting(1, 3, 4, 6) === 0)", "console.assert(areIntervalsIntersecting(10, 20, 20, 30) === 1)", "console.assert(areIntervalsIntersecting(10, 20, 21, 30) === 0)"], "challenge_test_list": [], "buggy_code": "function areIntervalsIntersecting(a, b, c, d)\n\n{\n    if ((c <= a && b <= undefined) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; \n    } else {\n        return 0; \n    }\n}"}
{"source_file": "unknown", "text": "Count the number of different permutation schemes for a binary string of length n, where the number of '1's is m and the number of '0's is n - m.\n\nParameters:\n@param {number} n - Length of the binary string.\n@param {number} m - Number of '1's in the binary string.\n\nReturns:\n@returns {number} The total number of different permutation schemes.", "code": "function countPermutationsOfBinaryString(n, m)\n{\n    let factorial = 1;\n    let i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    let numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    let denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    let denominator2 = factorial; // ((n-m)/2)!\n\n    // Check for edge cases\n    if ((n + m) % 2 === 1) {\n        return 0;\n    } else if (n === m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return Math.round(numerator / denominator1 / denominator2);\n    }\n}", "test_setup_code": "", "test_list": ["console.assert(countPermutationsOfBinaryString(2, 0) === 2)", "console.assert(countPermutationsOfBinaryString(2, 1) === 0)", "console.assert(countPermutationsOfBinaryString(3, 0) === 0)", "console.assert(countPermutationsOfBinaryString(3, 1) === 3)", "console.assert(countPermutationsOfBinaryString(3, 2) === 0)", "console.assert(countPermutationsOfBinaryString(30, 2) === 145422675)", "console.assert(countPermutationsOfBinaryString(4, 2) === 4)", "console.assert(countPermutationsOfBinaryString(5, 5) === 1)", "console.assert(countPermutationsOfBinaryString(33, 17) === 13884156)", "console.assert(countPermutationsOfBinaryString(1000, 1000) === 1)"], "challenge_test_list": [], "buggy_code": "function countPermutationsOfBinaryString(n, m)\n\n{\n    let factorial = 1;\n    let i;\n\n    \n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    let numerator = factorial; \n\n    \n    factorial = 1;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    let denominator1 = factorial; \n\n    \n    factorial = 1;\n    for (i = 2; i <= (m - n) / 2; ++i) {\n        factorial *= i;\n    }\n\n    let denominator2 = factorial; \n\n    \n    if ((n + m) % 2 === 1) {\n        return 0;\n    } else if (n === m) {\n        return 1;\n    } else {\n        \n        return Math.round(numerator / denominator1 / denominator2);\n    }\n}"}
{"source_file": "unknown", "text": "Calculates the year Y_n when the n-th event occurs, considering that each event has a periodicity of a_i years. The countdown for event i+1 starts the year after event i occurs.\nParameters:\n- n (number): The total number of events\n- signs (number[]): An array representing the periodicities of the events\nReturns:\n- number: The year when the n-th event occurs", "code": "function apocalypseYear(n, signs)\n{\n    let year = 0;\n    for (let i = 0; i < n; ++i) {\n        let period = signs[i];\n        let nextOccurrence = Math.floor(year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}", "test_setup_code": "", "test_list": ["console.assert(apocalypseYear(6, [3, 2, 4, 5, 9, 18]) === 36)", "console.assert(apocalypseYear(5, [1, 2, 3, 4, 5]) === 5)", "console.assert(apocalypseYear(5, [1, 1, 1, 1, 1]) === 5)", "console.assert(apocalypseYear(6, [50, 30, 711, 200, 503, 1006]) === 2012)", "console.assert(apocalypseYear(2, [1, 2]) === 2)", "console.assert(apocalypseYear(3, [3, 1, 2]) === 6)", "console.assert(apocalypseYear(3, [2, 3, 4]) === 4)", "console.assert(apocalypseYear(4, [1, 2, 3, 4]) === 4)", "console.assert(apocalypseYear(4, [5, 7, 11, 13]) === 13)", "console.assert(apocalypseYear(5, [2, 2, 2, 2, 2]) === 10)", "console.assert(apocalypseYear(3, [6, 10, 15]) === 15)", "console.assert(apocalypseYear(3, [4, 6, 14]) === 14)", "console.assert(apocalypseYear(4, [50, 30, 711, 200]) === 800)", "console.assert(apocalypseYear(6, [1, 1, 1, 1, 1, 1]) === 6)", "console.assert(apocalypseYear(2, [1000000, 999999]) === 1999998)"], "challenge_test_list": [], "buggy_code": "function apocalypseYear(n, signs)\n\n{\n    let year = 0;\n    for (let i = 0; i <= n; ++i) {\n        let period = signs[i];\n        let nextOccurrence = Math.floor(year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}"}
{"source_file": "unknown", "text": "Find the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n\nParameters:\n@param {number} n - A non-negative integer (0 ≤ n ≤ 2^64 - 1).\n\nReturns:\n@returns {number} The length of the longest consecutive sequence of 1s in the binary representation of the given integer.", "code": "function findLongestConsecutiveOnesLength(n)\n{\n    let max = 0;\n    let ans = 0;\n    while (n) {\n        if (n & 1)\n            ans++;\n        else {\n            if (ans > max)\n                max = ans;\n            ans = 0;\n        }\n        n >>>= 1;\n    }\n    if (ans > max)\n        max = ans;\n    return max;\n}", "test_setup_code": "", "test_list": ["console.assert(findLongestConsecutiveOnesLength(7) === 3)", "console.assert(findLongestConsecutiveOnesLength(13) === 2)", "console.assert(findLongestConsecutiveOnesLength(12345) === 3)", "console.assert(findLongestConsecutiveOnesLength(0b11011101111) === 4)", "console.assert(findLongestConsecutiveOnesLength(0xFFFFFFFF) === 32)", "console.assert(findLongestConsecutiveOnesLength(0) === 0)"], "challenge_test_list": [], "buggy_code": "function findLongestConsecutiveOnesLength(n)\n\n{\n    let max = 0;\n    let ans = 0;\n    while (num) {\n        if (num & 1)\n            ans++;\n        else {\n            if (ans > max)\n                max = ans;\n            ans = 0;\n        }\n        num >>>= 1;\n    }\n    if (ans > max)\n        max = ans;\n    return max;\n}"}
{"source_file": "unknown", "text": "Transforms the case of a given letter.\n- letter (char): The input letter to be transformed.\n\nReturns:\n- char: The letter with its case reversed. If the input is lowercase, returns uppercase, and if the input is uppercase, returns lowercase.", "code": "function transformLetterCase(letter)\n{\n    const charCode = letter.charCodeAt(0);\n    if (charCode >= 'A'.charCodeAt(0) && charCode <= 'Z'.charCodeAt(0)) {\n        // Convert uppercase to lowercase\n        return String.fromCharCode(charCode + ('a'.charCodeAt(0) - 'A'.charCodeAt(0)));\n    } else if (charCode >= 'a'.charCodeAt(0) && charCode <= 'z'.charCodeAt(0)) {\n        // Convert lowercase to uppercase\n        return String.fromCharCode(charCode - ('a'.charCodeAt(0) - 'A'.charCodeAt(0)));\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}", "test_setup_code": "", "test_list": ["console.assert(transformLetterCase('b') === 'B')", "console.assert(transformLetterCase('B') === 'b')", "console.assert(transformLetterCase('z') === 'Z')", "console.assert(transformLetterCase('Z') === 'z')", "console.assert(transformLetterCase('m') === 'M')", "console.assert(transformLetterCase('M') === 'm')", "console.assert(transformLetterCase('1') === '1'); // Non-alphabetic, should be unchanged", "console.assert(transformLetterCase('!') === '!'); // Non-alphabetic, should be unchanged"], "challenge_test_list": [], "buggy_code": "function transformLetterCase(letter)\n\n{\n    const charCode = number.charCodeAt(0);\n    if (charCode >= 'A'.charCodeAt(0) && charCode <= 'Z'.charCodeAt(0)) {\n        \n        return String.fromCharCode(charCode + ('a'.charCodeAt(0) - 'A'.charCodeAt(0)));\n    } else if (charCode >= 'a'.charCodeAt(0) && charCode <= 'z'.charCodeAt(0)) {\n        \n        return String.fromCharCode(charCode - ('a'.charCodeAt(0) - 'A'.charCodeAt(0)));\n    } else {\n        \n        return letter;\n    }\n}"}
{"source_file": "unknown", "text": "Checks if a string with exactly three characters has two characters that are the same.\n\nParameters:\n- str (string): The three-character string to be checked.\n\nReturns:\n- string: Returns 'Yes' if the input has exactly two equal characters, otherwise 'No'.", "code": "function checkTwoEqualDigits(str)\n{\n    if ((str[0] === str[1] && str[1] !== str[2]) ||\n        (str[0] === str[2] && str[0] !== str[1]) ||\n        (str[1] === str[2] && str[0] !== str[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}", "test_setup_code": "", "test_list": ["console.assert(checkTwoEqualDigits(\"112\") === \"Yes\")", "console.assert(checkTwoEqualDigits(\"123\") === \"No\")", "console.assert(checkTwoEqualDigits(\"232\") === \"Yes\")", "console.assert(checkTwoEqualDigits(\"444\") === \"No\"); // All three characters are equal, not two.", "console.assert(checkTwoEqualDigits(\"121\") === \"Yes\")", "console.assert(checkTwoEqualDigits(\"787\") === \"Yes\")", "console.assert(checkTwoEqualDigits(\"999\") === \"No\"); // All three characters are equal", "console.assert(checkTwoEqualDigits(\"890\") === \"No\")", "console.assert(checkTwoEqualDigits(\"556\") === \"Yes\")", "console.assert(checkTwoEqualDigits(\"353\") === \"Yes\"); // No two characters are equal"], "challenge_test_list": [], "buggy_code": "function checkTwoEqualDigits(str)\n\n{\n    if ((str[0] === str[1] && str[1] !== str[2]) ||\n        (str[0] === str[2] && str[0] !== str[1]) ||\n        (str[1] === str[2] && str[0] !== str[3])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}"}
{"source_file": "unknown", "text": "Given three integers n, m, and k, find the number of sequences consisting of n '(' and m ')', such that the longest balanced subsequence is of length 2 * k. The result should be calculated modulo 1,000,000,007 (10^9 + 7).", "code": "function countBalancedSubsequences(n, m, k)\n{\n    const P = 1e9 + 7;\n    const C = Array.from({ length: 4003 }, () => Array(4003).fill(0));\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] === 0) {\n        for (let i = 0; i <= 4002; i++) C[i][0] = 1;\n        for (let i = 1; i <= 4002; i++)\n            for (let j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    \n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}", "test_setup_code": "", "test_list": ["console.assert(countBalancedSubsequences(2, 2, 2) === 2)", "console.assert(countBalancedSubsequences(3, 2, 3) === 0)", "console.assert(countBalancedSubsequences(3, 2, 1) === 4)", "console.assert(countBalancedSubsequences(4, 3, 2) === 14)", "console.assert(countBalancedSubsequences(5, 5, 2) === 35)", "console.assert(countBalancedSubsequences(6, 1, 1) === 6)", "console.assert(countBalancedSubsequences(1, 6, 1) === 6)", "console.assert(countBalancedSubsequences(7, 2, 2) === 27)", "console.assert(countBalancedSubsequences(8, 3, 3) === 110)", "console.assert(countBalancedSubsequences(10, 10, 5) === 10659)", "console.assert(countBalancedSubsequences(20, 20, 10) === 574221648)", "console.assert(countBalancedSubsequences(2000, 2000, 1000) === 854104531)", "console.assert(countBalancedSubsequences(2000, 1999, 1000) === 334874485)", "console.assert(countBalancedSubsequences(2000, 2000, 1999) === 259428024)"], "challenge_test_list": [], "buggy_code": "function countBalancedSubsequences(n, m, k)\n\n{\n    const P = 1e9 + 7;\n    const C = Array.from({ length: 4003 }, () => Array(4003).fill(0));\n\n    \n    if (C[0][0] === 0) {\n        for (let i = 0; i <= 4002; i++) C[i][0] = 1;\n        for (let i = 1; i <= 4002; i++)\n            for (let j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    \n    if (k > n || k > m) return 0;\n\n    let k = 3; \n    \n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}"}
{"source_file": "unknown", "text": "Determine if two closed intervals intersect.\n\n@param {number} a - Start of the first closed interval, must satisfy 0 <= a <= b <= 1000.\n@param {number} b - End of the first closed interval, must satisfy 0 <= a <= b <= 1000.\n@param {number} c - Start of the second closed interval, must satisfy 0 <= c <= d <= 1000.\n@param {number} d - End of the second closed interval, must satisfy 0 <= c <= d <= 1000.\n@returns {number} 1 if the intervals intersect, 0 otherwise.", "code": "function areIntervalsIntersecting(a, b, c, d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}", "test_setup_code": "", "test_list": ["console.assert(areIntervalsIntersecting(1, 1, 1, 2) === 1)", "console.assert(areIntervalsIntersecting(3, 5, 2, 6) === 1)", "console.assert(areIntervalsIntersecting(3, 5, 4, 7) === 1)", "console.assert(areIntervalsIntersecting(3, 5, 6, 7) === 0)", "console.assert(areIntervalsIntersecting(0, 0, 0, 0) === 1)", "console.assert(areIntervalsIntersecting(1, 3, 2, 4) === 1)", "console.assert(areIntervalsIntersecting(1, 3, 4, 6) === 0)", "console.assert(areIntervalsIntersecting(10, 20, 20, 30) === 1)", "console.assert(areIntervalsIntersecting(10, 20, 21, 30) === 0)"], "challenge_test_list": [], "buggy_code": "function areIntervalsIntersecting(a, b, c, d)\n\n{\n    if ((c <= a && e <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; \n    } else {\n        return 0; \n    }\n}"}
{"source_file": "unknown", "text": "Given three digits a, b, and c, where two of them are equal and the third is different,\nthis function finds and returns the value that occurs exactly once.", "code": "function extraNumber(a, b, c)\n{\n    if (a === b) {\n        return c;\n    } else if (a === c) {\n        return b;\n    } else {\n        return a;\n    }\n}", "test_setup_code": "", "test_list": ["console.assert(extraNumber(2, 7, 2) === 7)", "console.assert(extraNumber(3, 2, 2) === 3)", "console.assert(extraNumber(5, 5, 1) === 1)", "console.assert(extraNumber(500000000, 3, 500000000) === 3)", "console.assert(extraNumber(500000000, 500000000, 3) === 3)"], "challenge_test_list": [], "buggy_code": "function extraNumber(a, b, c)\n\n{\n    if (a === b) {\n        return c;\n    } else if (a === c) {\n        return b;\n    } else {\n        return d;\n    }\n}"}
{"source_file": "unknown", "text": "Given an integer n, write a function to compute the sum of all numbers from 1 to n that are multiples of either 3 or 5. If a number is a multiple of both 3 and 5, it should only be counted once.", "code": "function sumOfMultiples(n)\n{\n    let sum = 0;\n    for (let i = 1; i <= n; ++i) {\n        if (i % 3 === 0 || i % 5 === 0) {\n            sum += i;\n        }\n    }\n    return sum;\n}", "test_setup_code": "", "test_list": ["console.assert(sumOfMultiples(10) === 33)", "console.assert(sumOfMultiples(15) === 60)", "console.assert(sumOfMultiples(20) === 98)", "console.assert(sumOfMultiples(5) === 8)", "console.assert(sumOfMultiples(3) === 3)", "console.assert(sumOfMultiples(6) === 14)", "console.assert(sumOfMultiples(9) === 23)", "console.assert(sumOfMultiples(12) === 45)", "console.assert(sumOfMultiples(17) === 60)", "console.assert(sumOfMultiples(21) === 119)", "console.assert(sumOfMultiples(25) === 168)"], "challenge_test_list": [], "buggy_code": "function sumOfMultiples(n)\n\n{\n    let total = 0;\n    for (let i = 1; i <= n; ++i) {\n        if (i % 3 === 0 || i % 5 === 0) {\n            sum += i;\n        }\n    }\n    return sum;\n}"}
{"source_file": "unknown", "text": "Given a sequence of student IDs entering a classroom, where the IDs range from 0 to N-1,\ncalculate the total number of handshakes that occur. Each student will shake hands with\nevery student already in the classroom who has a smaller ID number. The sequence represents\nthe order in which students enter the classroom.", "code": "function countHandshakes(n, order)\n{\n    let ans = 0;\n    const tr = new Array(n + 1).fill(0); // Increase the size to accommodate 1-indexed values.\n    for (let i = 0; i < n; ++i) {\n        let x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (let j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (let j = x; j <= n; j += j & (-j)) {\n            tr[j]++;\n        }\n    }\n    return ans;\n}", "test_setup_code": "", "test_list": ["console.assert(countHandshakes(4, [2, 1, 3, 0]) === 2)", "console.assert(countHandshakes(6, [0, 1, 2, 3, 4, 5]) === 15)", "console.assert(countHandshakes(3, [1, 2, 0]) === 1)", "console.assert(countHandshakes(4, [3, 2, 1, 0]) === 0)", "console.assert(countHandshakes(4, [0, 1, 2, 3]) === 6)", "console.assert(countHandshakes(6, [5, 4, 3, 2, 1, 0]) === 0)", "console.assert(countHandshakes(4, [0, 2, 1, 3]) === 5)", "console.assert(countHandshakes(5, [3, 1, 4, 2, 0]) === 3)", "console.assert(countHandshakes(4, [1, 0, 3, 2]) === 4)", "console.assert(countHandshakes(3, [2, 0, 1]) === 1)", "console.assert(countHandshakes(5, [1, 3, 0, 2, 4]) === 7)", "console.assert(countHandshakes(5, [4, 3, 2, 1, 0]) === 0)"], "challenge_test_list": [], "buggy_code": "function countHandshakes(n, order)\n\n{\n    let ans = 0;\n    const tr = new Array(n + 1).fill(0); \n    for (let i = 0; i < n; ++i) {\n        let x = order[i] + 1; \n        for (let j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (let j = x; j <= n; j += j & (-j)) {\n            tr[j]++;\n        }\n    }\n    return ans.someUndefinedMethod(); \n}"}
{"source_file": "unknown", "text": "Display the ASCII information for a given character.\n\nParameters:\n@param {char} character - The input character for which ASCII information is to be displayed.\n\nReturns:\n@returns {number} - The corresponding ASCII code.\n\nExamples:\ndisplay_ascii_info('A');\n// => 65", "code": "function display_ascii_info(character)\n{\n    return character.charCodeAt(0);\n}", "test_setup_code": "", "test_list": ["console.assert(display_ascii_info('A') === 65)", "console.assert(display_ascii_info('B') === 66)", "console.assert(display_ascii_info('0') === 48)", "console.assert(display_ascii_info(' ') === 32)"], "challenge_test_list": [], "buggy_code": "function display_ascii_info(character)\n\n{\n    return character.badMethod(0);\n}"}
{"source_file": "unknown", "text": "Given n positive integers representing the count of each number from 1 to n, find the maximum sum of the mode (most frequent element) for all prefixes of a sequence constructed from these numbers. The mode is the largest number among the most frequent elements in a sequence.", "code": "function maxModeSum(n, counts)\n{\n  let ans = 0;\n  let mx = 0;\n  let f = new Array(100000).fill(0); // Initialize the array with zeroes\n\n  for (let i = 0; i <= n; ++i) {\n    f[i] = 0;\n  }\n\n  for (let i = n; i > 0; --i) {\n    while (mx < counts[i - 1]) {\n      mx++;\n      f[mx] = f[mx - 1] + i;\n    }\n    ans += f[counts[i - 1]];\n  }\n  return ans;\n}", "test_setup_code": "", "test_list": ["console.assert(maxModeSum(3, [1, 3, 2]) === 17)", "console.assert(maxModeSum(4, [4, 1, 2, 3]) === 37)", "console.assert(maxModeSum(2, [1, 1]) === 4)", "console.assert(maxModeSum(5, [1, 2, 3, 4, 5]) === 75)", "console.assert(maxModeSum(1, [100000]) === 100000)", "console.assert(maxModeSum(5, [5, 3, 2, 4, 1]) === 62)", "console.assert(maxModeSum(3, [100000, 100000, 100000]) === 900000)", "console.assert(maxModeSum(3, [2, 2, 5]) === 27)", "console.assert(maxModeSum(4, [4, 4, 4, 4]) === 64)", "console.assert(maxModeSum(6, [1, 2, 3, 4, 5, 6]) === 126)", "console.assert(maxModeSum(3, [3, 1, 2]) === 16)"], "challenge_test_list": [], "buggy_code": "function maxModeSum(n, counts)\n\n{\n  let ans = 0;\n  let mx = 0;\n  let f = new Array(100000).fill(0); \n\n  for (let i = 0; i <= n; ++i) {\n    f[i] = 0;\n  }\n\n  for (let i = n; i > 0; --i) {\n    while (mx < counts[i - 1]) {\n      mx++;\n      f[mx] = f[mx - 1] + i;\n    }\n    ans += f.count;\n  }\n  return ans;\n}"}
{"source_file": "unknown", "text": "Shifts all characters by 5 positions in alphabetical order.\nOnly letters are replaced, and all letters are in uppercase.\n\nParameters:\n- text (string): The input text to be processed.\n\nReturns:\n- string: The transformed text with characters shifted by 5 positions.", "code": "function shiftCharacters(text)\n{\n    let shiftedText = '';\n    for (let i = 0; i < text.length; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            shiftedText += String.fromCharCode(text.charCodeAt(i) + 21); // 'V' - 'A' = 21\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            shiftedText += String.fromCharCode(text.charCodeAt(i) - 5); // 'A' - 'F' = -5\n        } else {\n            shiftedText += text[i];\n        }\n    }\n    return shiftedText;\n}", "test_setup_code": "", "test_list": ["console.assert(shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") === \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\")", "console.assert(shiftCharacters(\"N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ\") === \"I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME\")", "console.assert(shiftCharacters(\"IFSLJW PSTBX KZQQ BJQQ YMFY HFJXFW NX RTWJ IFSLJWTZX YMFS MJ\") === \"DANGER KNOWS FULL WELL THAT CAESAR IS MORE DANGEROUS THAN HE\")"], "challenge_test_list": [], "buggy_code": "function shiftCharacters(text)\n\n{\n    let shiftedText = '';\n    for (let i = 0; i < text.length; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            shiftedText += String.fromCharCode(text.charCodeAt(i) + 21); \n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            shiftedText += String.fromCharCode(text.charCodeAt(i) - 5); \n        } else {\n            shiftedText += text[i];\n        }\n    }\n    return shiftText();\n}"}
{"source_file": "unknown", "text": "Given a string consisting of lowercase English letters, you can change one character to another in each round. This function calculates the minimum number of rounds needed to make the string composed of the same character.\n@param {string} s - The input string.\n@returns {number} The minimum number of rounds to make all characters in the string the same.", "code": "function minRoundsToSameChar(s)\n{\n    const charCount = new Array(26).fill(0); // Assuming only lowercase letters\n    for (const char of s) {\n        charCount[char.charCodeAt(0) - 'a'.charCodeAt(0)]++;\n    }\n    let maxCount = 0;\n    for (const count of charCount) {\n        if (count !== 0) {\n            maxCount++;\n        }\n    }\n\n    return maxCount - 1;\n}", "test_setup_code": "", "test_list": ["console.assert(minRoundsToSameChar(\"aab\") === 1)", "console.assert(minRoundsToSameChar(\"abc\") === 2)", "console.assert(minRoundsToSameChar(\"aaa\") === 0)", "console.assert(minRoundsToSameChar(\"abab\") === 1)", "console.assert(minRoundsToSameChar(\"zzzzz\") === 0)"], "challenge_test_list": [], "buggy_code": "function minRoundsToSameChar(s)\n\n{\n    const charCount = new Array(26).fill(0); \n    for (const char of s) {\n        charCount[char.charCodeAt(0) - \"a.charCodeAt(0)]++;\n    }\n    let maxCount = 0;\n    for (const count of charCount) {\n        if (count !== 0) {\n            maxCount++;\n        }\n    }\n\n    return maxCount - 1;\n}"}
{"source_file": "unknown", "text": "Decode a series of numbers to reveal the pattern and understand the actual values each digit represents. The patterns are as follows: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nParameters:\n- dataStr (string): A string representing a series of numbers. The length does not exceed 100 characters.\n\nReturns:\n- number: The result corresponding to each data string as per the pattern.", "code": "function decodeNumbers(dataStr)\n{\n    // Mapping values as per the given pattern\n    const a = [1, 0, 0, 0, 1, 0, 1, 0, 2, 1];\n    let ans = 0;\n    for (let i = 0; i < dataStr.length; i++) {\n        ans += a[dataStr[i] - '0']; // Subtracting '0' to convert char to actual number\n    }\n    return ans;\n}", "test_setup_code": "", "test_list": ["console.assert(decodeNumbers(\"0000\") === 4)", "console.assert(decodeNumbers(\"8888\") === 8)", "console.assert(decodeNumbers(\"1234\") === 1)", "console.assert(decodeNumbers(\"5678\") === 3)", "console.assert(decodeNumbers(\"9012\") === 2)", "console.assert(decodeNumbers(\"1357\") === 0)", "console.assert(decodeNumbers(\"2468\") === 4)", "console.assert(decodeNumbers(\"9999\") === 4)", "console.assert(decodeNumbers(\"1111\") === 0)", "console.assert(decodeNumbers(\"2222\") === 0)", "console.assert(decodeNumbers(\"3333\") === 0)", "console.assert(decodeNumbers(\"4444\") === 4)", "console.assert(decodeNumbers(\"5555\") === 0)", "console.assert(decodeNumbers(\"6666\") === 4)", "console.assert(decodeNumbers(\"7777\") === 0)", "console.assert(decodeNumbers(\"0001\") === 3)", "console.assert(decodeNumbers(\"2301\") === 1)"], "challenge_test_list": [], "buggy_code": "function decodeNumbers(dataStr)\n\n{\n    \n    const a = [1, 0, 0, 0, 1, 0, 1, 0, 2, 1];\n    let ans = 0;\n    for (let i = 0; i < dataStr.length; i++) {\n        ans += a[dataStr[i] - \"0]; \n    }\n    return ans;\n}"}
{"source_file": "unknown", "text": "Checks if a string with exactly three characters has two characters that are the same.\n\nParameters:\n- str (string): The three-character string to be checked.\n\nReturns:\n- string: Returns 'Yes' if the input has exactly two equal characters, otherwise 'No'.", "code": "function checkTwoEqualDigits(str)\n{\n    if ((str[0] === str[1] && str[1] !== str[2]) ||\n        (str[0] === str[2] && str[0] !== str[1]) ||\n        (str[1] === str[2] && str[0] !== str[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}", "test_setup_code": "", "test_list": ["console.assert(checkTwoEqualDigits(\"112\") === \"Yes\")", "console.assert(checkTwoEqualDigits(\"123\") === \"No\")", "console.assert(checkTwoEqualDigits(\"232\") === \"Yes\")", "console.assert(checkTwoEqualDigits(\"444\") === \"No\"); // All three characters are equal, not two.", "console.assert(checkTwoEqualDigits(\"121\") === \"Yes\")", "console.assert(checkTwoEqualDigits(\"787\") === \"Yes\")", "console.assert(checkTwoEqualDigits(\"999\") === \"No\"); // All three characters are equal", "console.assert(checkTwoEqualDigits(\"890\") === \"No\")", "console.assert(checkTwoEqualDigits(\"556\") === \"Yes\")", "console.assert(checkTwoEqualDigits(\"353\") === \"Yes\"); // No two characters are equal"], "challenge_test_list": [], "buggy_code": "function checkTwoEqualDigits(str)\n\n{\n    if ((str[0] === str[1] && str[1] !== str[2]) ||\n        (str[0] === str[2] && str[0] !== str[1]) ||\n        (str[1] === str[2] && str[0] !== str[1])) {\n        return \"Yes;\n    } else {\n        return \"No\";\n    }\n}"}
{"source_file": "unknown", "text": "Creates an ID by combining two strings in a specific manner.\nParameters:\n- word1 (string): The first string to be used in the ID.\n- word2 (string): The second string to be used in the ID.\nReturns:\nstring: A divine ID formed by reversing every other character of the second string and combining it with the first string.", "code": "function createId(word1, word2)\n{\n    let id = '';\n    for (let i = 0, k = 0, j = word2.length - 1; i < word1.length + word2.length; i++) {\n        if (i % 2 === 0) {\n            id += word1.charAt(k++); // Take character from word1\n        } else {\n            id += word2.charAt(j--); // Take character from word2 in reverse\n        }\n    }\n    return id;\n}", "test_setup_code": "", "test_list": ["console.assert(createId(\"fish\", \"cat\") === \"ftiasch\")", "console.assert(createId(\"icpc\", \"acm\") === \"imccpac\")", "console.assert(createId(\"oo\", \"w\") === \"owo\")", "console.assert(createId(\"hello\", \"world\") === \"hdellrloow\")", "console.assert(createId(\"abc\", \"def\") === \"afbecd\")", "console.assert(createId(\"buaanb\", \"nbbuaa\") === \"bauaauabnbbn\")", "console.assert(createId(\"xtuisgood\", \"ilovextu\") === \"xuttuxiesvgooloid\")"], "challenge_test_list": [], "buggy_code": "function createId(word1, word2)\n\n{\n    let id = '';\n    for (let i = 0, k = 0, j = word2.length - 1; i < word1.length + word2.length; i++) {\n        if (i % 2 === 0) {\n            id += word1.charAt(k++); \n        } else {\n            id += word2.charAt(j--); \n        }\n    }\n    id += \"unclosed string;\n    return id;\n}"}
{"source_file": "unknown", "text": "Transforms the case of a given letter.\n- letter (char): The input letter to be transformed.\n\nReturns:\n- char: The letter with its case reversed. If the input is lowercase, returns uppercase, and if the input is uppercase, returns lowercase.", "code": "function transformLetterCase(letter)\n{\n    const charCode = letter.charCodeAt(0);\n    if (charCode >= 'A'.charCodeAt(0) && charCode <= 'Z'.charCodeAt(0)) {\n        // Convert uppercase to lowercase\n        return String.fromCharCode(charCode + ('a'.charCodeAt(0) - 'A'.charCodeAt(0)));\n    } else if (charCode >= 'a'.charCodeAt(0) && charCode <= 'z'.charCodeAt(0)) {\n        // Convert lowercase to uppercase\n        return String.fromCharCode(charCode - ('a'.charCodeAt(0) - 'A'.charCodeAt(0)));\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}", "test_setup_code": "", "test_list": ["console.assert(transformLetterCase('b') === 'B')", "console.assert(transformLetterCase('B') === 'b')", "console.assert(transformLetterCase('z') === 'Z')", "console.assert(transformLetterCase('Z') === 'z')", "console.assert(transformLetterCase('m') === 'M')", "console.assert(transformLetterCase('M') === 'm')", "console.assert(transformLetterCase('1') === '1'); // Non-alphabetic, should be unchanged", "console.assert(transformLetterCase('!') === '!'); // Non-alphabetic, should be unchanged"], "challenge_test_list": [], "buggy_code": "function transformLetterCase(letter)\n\n{\n    const charCode = letter.charCodeAt(0);\n    if (charCode >= 'A.charCodeAt(0) && charCode <= 'Z'.charCodeAt(0)) {\n        \n        return String.fromCharCode(charCode + ('a'.charCodeAt(0) - 'A'.charCodeAt(0)));\n    } else if (charCode >= 'a'.charCodeAt(0) && charCode <= 'z'.charCodeAt(0)) {\n        \n        return String.fromCharCode(charCode - ('a'.charCodeAt(0) - 'A'.charCodeAt(0)));\n    } else {\n        \n        return letter;\n    }\n}"}
{"source_file": "unknown", "text": "Count the number of different permutation schemes for a binary string of length n, where the number of '1's is m and the number of '0's is n - m.\n\nParameters:\n@param {number} n - Length of the binary string.\n@param {number} m - Number of '1's in the binary string.\n\nReturns:\n@returns {number} The total number of different permutation schemes.", "code": "function countPermutationsOfBinaryString(n, m)\n{\n    let factorial = 1;\n    let i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    let numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    let denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    let denominator2 = factorial; // ((n-m)/2)!\n\n    // Check for edge cases\n    if ((n + m) % 2 === 1) {\n        return 0;\n    } else if (n === m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return Math.round(numerator / denominator1 / denominator2);\n    }\n}", "test_setup_code": "", "test_list": ["console.assert(countPermutationsOfBinaryString(2, 0) === 2)", "console.assert(countPermutationsOfBinaryString(2, 1) === 0)", "console.assert(countPermutationsOfBinaryString(3, 0) === 0)", "console.assert(countPermutationsOfBinaryString(3, 1) === 3)", "console.assert(countPermutationsOfBinaryString(3, 2) === 0)", "console.assert(countPermutationsOfBinaryString(30, 2) === 145422675)", "console.assert(countPermutationsOfBinaryString(4, 2) === 4)", "console.assert(countPermutationsOfBinaryString(5, 5) === 1)", "console.assert(countPermutationsOfBinaryString(33, 17) === 13884156)", "console.assert(countPermutationsOfBinaryString(1000, 1000) === 1)"], "challenge_test_list": [], "buggy_code": "function countPermutationsOfBinaryString(n, m)\n\n{\n    let factorial == 1;\n    let i;\n\n    \n    for (i == 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    let numerator = factorial; \n\n    \n    factorial = 1;\n    for (i == 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    let denominator1 = factorial; \n\n    \n    factorial = 1;\n    for (i == 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    let denominator2 = factorial; \n\n    \n    if ((n + m) % 2 === 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        \n        return Math.round(numerator / denominator1 / denominator2);\n    }\n}"}
{"source_file": "unknown", "text": "Determines the number of ways to choose a triplet (a, b, c) from an array of distinct integers representing heights such that the greatest common divisor (GCD) of the maximum and minimum values of the triplet is 1.", "code": "function countTriplets(heights)\n{\n    let count = 0;\n    const n = heights.length;\n    for (let i = 0; i < n; ++i) {\n        for (let j = i + 1; j < n; ++j) {\n            for (let k = j + 1; k < n; ++k) {\n                const minVal = Math.min(heights[i], heights[j], heights[k]);\n                const maxVal = Math.max(heights[i], heights[j], heights[k]);\n                if (gcd(minVal, maxVal) === 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\n// Helper function to find the greatest common divisor\nfunction gcd(a, b) {\n    while (b !== 0) {\n        let t = b;\n        b = a % b;\n        a = t;\n    }\n    return a;\n}", "test_setup_code": "", "test_list": ["console.assert(countTriplets([1, 5, 7]) === 1)", "console.assert(countTriplets([1, 6, 2, 3]) === 3)", "console.assert(countTriplets([16, 4, 8, 2]) === 0)", "console.assert(countTriplets([10, 1, 6, 7, 9, 8, 4, 3, 5, 2]) === 77)", "console.assert(countTriplets([4, 5, 9, 11, 14]) === 7)", "console.assert(countTriplets([15, 10, 6, 9, 7, 3, 12, 8, 11, 1, 2]) === 104)", "console.assert(countTriplets([3, 7, 11, 13]) === 4)", "console.assert(countTriplets([5, 12, 13, 17, 19]) === 10)", "console.assert(countTriplets([2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]) === 87)", "console.assert(countTriplets([1, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]) === 122)"], "challenge_test_list": [], "buggy_code": "function countTriplets(heights)\n\n{\n    let count = 0;\n    const n = heights.length;\n    for (let i = 0; i < n; ++i) {\n        for (let j = i + 1; j < n; ++j) {\n            for (let k = j + 1; k < n; ++k) {\n                const minVal = Math.min(heights[i], heights[j], heights[k]);\n                const maxVal = Math.max(heights[i], heights[j], heights[k]);\n                if (gcd(minVal, maxVal) = 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\n\nfunction gcd(a, b) {\n    while (b !== 0) {\n        let t = b;\n        b = a % b;\n        a = t;\n    }\n    return a;\n}"}
{"source_file": "unknown", "text": "Calculate the sum of even numbers in a given list.\nParameters:\n- numbers (Array): An array of integers.\n- size (Number): The size of the array.\nReturns:\n  Number: The sum of even numbers in the input array.\nExample usage:\n  calculateEvenSum([1, 4, 3, 2, 5], 5)  // returns 6", "code": "function calculateEvenSum(numbers, size)\n{\n    let ans = 0;\n    for (let i = 0; i < size; i++) {\n        if (numbers[i] % 2 === 0) { // Only sum the even numbers\n            ans += numbers[i];\n        }\n    }\n    return ans;\n}", "test_setup_code": "", "test_list": ["console.assert(calculateEvenSum([1, 4, 3, 2, 5], 5) === 6)", "console.assert(calculateEvenSum([2, 2, 0, 0], 4) === 4)", "console.assert(calculateEvenSum([7, 11, 19], 3) === 0); // Should return 0 because there are no even numbers", "console.assert(calculateEvenSum([12, 14, 16, 18, 20], 5) === (12 + 14 + 16 + 18 + 20))"], "challenge_test_list": [], "buggy_code": "function calculateEvenSum(numbers, size)\n\n{\n    let ans = 0;\n    for (let i = 0; i < size; i++) {\n        if (numbers[i] % 2 = 0) { \n            ans += numbers[i];\n        }\n    }\n    return ans;\n}"}
{"source_file": "unknown", "text": "Given a sequence of N piles of stones numbered from 1 to N, with each pile containing a positive number of stones,\n determine the winner of a game played by Charlie and Dan. Charlie goes first, and they take turns moving a\n positive number of stones from the leftmost non-empty pile to the adjacent right pile. The player who can\n only move stones in the last pile loses. Assuming both players use the best possible strategy, find out\n who will win the game.", "code": "function gameWinner(piles)\n{\n    const n = piles.length;\n    const firstPileStones = piles[0];\n    \n    if (n === 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones === 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}", "test_setup_code": "", "test_list": ["console.assert(gameWinner([1, 2, 2]) === \"Dan\")", "console.assert(gameWinner([5, 5, 5, 5, 5]) === \"Charlie\")", "console.assert(gameWinner([2, 1, 2]) === \"Charlie\")", "console.assert(gameWinner([3, 3, 3, 3]) === \"Charlie\")", "console.assert(gameWinner([1, 1]) === \"Charlie\")", "console.assert(gameWinner([2, 1]) === \"Charlie\")", "console.assert(gameWinner([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) === \"Dan\")", "console.assert(gameWinner([2, 2, 2, 2, 2, 2, 2, 2, 2, 1]) === \"Charlie\")", "console.assert(gameWinner([10, 10, 10, 10, 10, 10, 10, 10, 10, 10]) === \"Charlie\")", "console.assert(gameWinner([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) === \"Dan\")"], "challenge_test_list": [], "buggy_code": "function gameWinner(piles)\n\n{\n    const n = piles.length;\n    const firstPileStones = piles[0];\n    \n    if (n = 2) { \n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { \n        return \"Dan\";\n    }\n    return \"Charlie\"; \n}"}
{"source_file": "unknown", "text": "Calculates the year Y_n when the n-th event occurs, considering that each event has a periodicity of a_i years. The countdown for event i+1 starts the year after event i occurs.\nParameters:\n- n (number): The total number of events\n- signs (number[]): An array representing the periodicities of the events\nReturns:\n- number: The year when the n-th event occurs", "code": "function apocalypseYear(n, signs)\n{\n    let year = 0;\n    for (let i = 0; i < n; ++i) {\n        let period = signs[i];\n        let nextOccurrence = Math.floor(year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}", "test_setup_code": "", "test_list": ["console.assert(apocalypseYear(6, [3, 2, 4, 5, 9, 18]) === 36)", "console.assert(apocalypseYear(5, [1, 2, 3, 4, 5]) === 5)", "console.assert(apocalypseYear(5, [1, 1, 1, 1, 1]) === 5)", "console.assert(apocalypseYear(6, [50, 30, 711, 200, 503, 1006]) === 2012)", "console.assert(apocalypseYear(2, [1, 2]) === 2)", "console.assert(apocalypseYear(3, [3, 1, 2]) === 6)", "console.assert(apocalypseYear(3, [2, 3, 4]) === 4)", "console.assert(apocalypseYear(4, [1, 2, 3, 4]) === 4)", "console.assert(apocalypseYear(4, [5, 7, 11, 13]) === 13)", "console.assert(apocalypseYear(5, [2, 2, 2, 2, 2]) === 10)", "console.assert(apocalypseYear(3, [6, 10, 15]) === 15)", "console.assert(apocalypseYear(3, [4, 6, 14]) === 14)", "console.assert(apocalypseYear(4, [50, 30, 711, 200]) === 800)", "console.assert(apocalypseYear(6, [1, 1, 1, 1, 1, 1]) === 6)", "console.assert(apocalypseYear(2, [1000000, 999999]) === 1999998)"], "challenge_test_list": [], "buggy_code": "function apocalypseYear(n, signs)\n\n{\n    let year = 0;\n    for (let i = 0; i < n; ++i) {\n        let period = signs[i];\n       \n        year = nextOccurrence;\n    }\n    return year;\n}"}
{"source_file": "unknown", "text": "Given a sequence of N piles of stones numbered from 1 to N, with each pile containing a positive number of stones,\n determine the winner of a game played by Charlie and Dan. Charlie goes first, and they take turns moving a\n positive number of stones from the leftmost non-empty pile to the adjacent right pile. The player who can\n only move stones in the last pile loses. Assuming both players use the best possible strategy, find out\n who will win the game.", "code": "function gameWinner(piles)\n{\n    const n = piles.length;\n    const firstPileStones = piles[0];\n    \n    if (n === 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones === 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}", "test_setup_code": "", "test_list": ["console.assert(gameWinner([1, 2, 2]) === \"Dan\")", "console.assert(gameWinner([5, 5, 5, 5, 5]) === \"Charlie\")", "console.assert(gameWinner([2, 1, 2]) === \"Charlie\")", "console.assert(gameWinner([3, 3, 3, 3]) === \"Charlie\")", "console.assert(gameWinner([1, 1]) === \"Charlie\")", "console.assert(gameWinner([2, 1]) === \"Charlie\")", "console.assert(gameWinner([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) === \"Dan\")", "console.assert(gameWinner([2, 2, 2, 2, 2, 2, 2, 2, 2, 1]) === \"Charlie\")", "console.assert(gameWinner([10, 10, 10, 10, 10, 10, 10, 10, 10, 10]) === \"Charlie\")", "console.assert(gameWinner([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) === \"Dan\")"], "challenge_test_list": [], "buggy_code": "function gameWinner(piles)\n\n{\n    const n = piles.length;\n    const firstPileStones = piles[0];\n    \n    /* if (n === 2) { \n        return \"Charlie\";\n    }\n    if (firstPileStones === 1) { \n        return \"Dan\";\n    }\n    return \"Charlie\"; \n}"}
{"source_file": "unknown", "text": "Given an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\nA subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= the length of the array.\nThe XOR sum of a subarray is the result of XORing all elements from L to R.\nThe final result is the sum of the XOR sums for all possible subarrays.", "code": "function sumOfXorSubarrays(A)\n{\n    const n = A.length;\n    let q = new Array(n + 1).fill(0);\n    let w = Array.from({ length: 21 }, () => [0, 0]);\n    let ans = 0;\n\n    for (let i = 1; i <= n; i++) {\n        q[i] = q[i - 1] ^ A[i - 1];\n    }\n\n    for (let i = 0; i <= n; i++) {\n        for (let j = 20; j >= 0; j--) {\n            w[j][(q[i] >> j) & 1]++;\n        }\n    }\n\n    for (let i = 0; i <= 20; i++) {\n        ans += w[i][0] * w[i][1] * (1 << i);\n    }\n\n    return ans;\n}", "test_setup_code": "", "test_list": ["console.assert(sumOfXorSubarrays([1, 2, 3, 4, 5]) === 39)", "console.assert(sumOfXorSubarrays([1, 1, 1]) === 4)", "console.assert(sumOfXorSubarrays([2, 3, 1]) === 9)", "console.assert(sumOfXorSubarrays([4, 5, 7, 9]) === 74)", "console.assert(sumOfXorSubarrays([0, 0, 0, 0]) === 0)", "console.assert(sumOfXorSubarrays([8, 8, 8, 8, 8]) === 72)", "console.assert(sumOfXorSubarrays([3, 6, 9, 12, 15]) === 125)", "console.assert(sumOfXorSubarrays([10, 20, 30, 40, 50]) === 390)", "console.assert(sumOfXorSubarrays([16, 16, 16, 16, 16, 16]) === 192)", "console.assert(sumOfXorSubarrays([1, 3, 5, 7, 9, 11, 13]) === 192)", "console.assert(sumOfXorSubarrays([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) === 218)"], "challenge_test_list": [], "buggy_code": "function sumOfXorSubarrays(A)\n\n{\n    const n = A.length;\n    let q = new Array(n + 1).fill(0);\n    let w = Array.from({ length: 21 }, () => [0, 0]);\n    let ans = 0;\n\n    for (let i = 1; i <= n; i++) {\n        q[i] = q[i - 1] ^ A[i - 1];\n    }\n\n    for (let i = 0; i <= n; i++) {\n        for (let j = 20; j >= 0; j--) {\n            \n            w[j][(q[i] >> j) & 1];\n        }\n    }\n\n    for (let i = 0; i <= 20; i++) {\n        ans += w[i][0] * w[i][1] * (1 << i);\n    }\n\n    return ans;\n}"}
{"source_file": "unknown", "text": "Evaluate the grade for an input integer.\n\nParameters:\n- score (int): The integer score to be evaluated.\n\nReturns:\n    char: The grade corresponding to the input score.\n    If the score is between 90 and 100 (inclusive), returns 'A'.\n    Otherwise, returns 'B'.", "code": "function evaluate_integer_grade(score)\n{\n    // Return 'A' or 'B' based on the condition\n    return ((90 <= score && score <= 100) ? 'A' : 'B');\n}", "test_setup_code": "", "test_list": ["console.assert(evaluate_integer_grade(90) === 'A')", "console.assert(evaluate_integer_grade(89) === 'B')", "console.assert(evaluate_integer_grade(95) === 'A')", "console.assert(evaluate_integer_grade(100) === 'A')", "console.assert(evaluate_integer_grade(101) === 'B')"], "challenge_test_list": [], "buggy_code": "function evaluate_integer_grade(score)\n\n{\n    / Return 'A' or 'B' based on the condition\n    return ((90 <= score && score <= 100) ? 'A' : 'B');\n}"}
{"source_file": "unknown", "text": "Display the ASCII information for a given character.\n\nParameters:\n@param {char} character - The input character for which ASCII information is to be displayed.\n\nReturns:\n@returns {number} - The corresponding ASCII code.", "code": "function display_ascii_info(character)\n{\n    return character.charCodeAt(0);\n}", "test_setup_code": "", "test_list": ["console.assert(display_ascii_info('A') === 65)", "console.assert(display_ascii_info('B') === 66)", "console.assert(display_ascii_info('0') === 48)", "console.assert(display_ascii_info(' ') === 32)"], "challenge_test_list": [], "buggy_code": "function display_ascii_info(character)\n\n{\n    return character.charCodeAt(1);\n}"}
{"source_file": "unknown", "text": "Count the number of different permutation schemes for a binary string of length n, where the number of '1's is m and the number of '0's is n - m.\n\nParameters:\n@param {number} n - Length of the binary string.\n@param {number} m - Number of '1's in the binary string.\n\nReturns:\n@returns {number} The total number of different permutation schemes.", "code": "function countPermutationsOfBinaryString(n, m)\n{\n    let factorial = 1;\n    let i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    let numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    let denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    let denominator2 = factorial; // ((n-m)/2)!\n\n    // Check for edge cases\n    if ((n + m) % 2 === 1) {\n        return 0;\n    } else if (n === m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return Math.round(numerator / denominator1 / denominator2);\n    }\n}", "test_setup_code": "", "test_list": ["console.assert(countPermutationsOfBinaryString(2, 0) === 2)", "console.assert(countPermutationsOfBinaryString(2, 1) === 0)", "console.assert(countPermutationsOfBinaryString(3, 0) === 0)", "console.assert(countPermutationsOfBinaryString(3, 1) === 3)", "console.assert(countPermutationsOfBinaryString(3, 2) === 0)", "console.assert(countPermutationsOfBinaryString(30, 2) === 145422675)", "console.assert(countPermutationsOfBinaryString(4, 2) === 4)", "console.assert(countPermutationsOfBinaryString(5, 5) === 1)", "console.assert(countPermutationsOfBinaryString(33, 17) === 13884156)", "console.assert(countPermutationsOfBinaryString(1000, 1000) === 1)"], "challenge_test_list": [], "buggy_code": "function countPermutationsOfBinaryString(n, m)\n\n{\n    let factorial = 1;\n    let i;\n\n    \n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    let numerator = factorial; \n\n    \n    factorial = 1;\n    for (i = 2; i <= n + m / 2; ++i) {\n        factorial *= i;\n    }\n\n    let denominator1 = factorial; \n\n    \n    factorial = 1;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    let denominator2 = factorial; \n\n    \n    if ((n + m) % 2 === 1) {\n        return 0;\n    } else if (n === m) {\n        return 1;\n    } else {\n        \n        return Math.round(numerator / denominator1 / denominator2);\n    }\n}"}
{"source_file": "unknown", "text": "Given n positive integers representing the count of each number from 1 to n, find the maximum sum of the mode (most frequent element) for all prefixes of a sequence constructed from these numbers. The mode is the largest number among the most frequent elements in a sequence.", "code": "function maxModeSum(n, counts)\n{\n  let ans = 0;\n  let mx = 0;\n  let f = new Array(100000).fill(0); // Initialize the array with zeroes\n\n  for (let i = 0; i <= n; ++i) {\n    f[i] = 0;\n  }\n\n  for (let i = n; i > 0; --i) {\n    while (mx < counts[i - 1]) {\n      mx++;\n      f[mx] = f[mx - 1] + i;\n    }\n    ans += f[counts[i - 1]];\n  }\n  return ans;\n}", "test_setup_code": "", "test_list": ["console.assert(maxModeSum(3, [1, 3, 2]) === 17)", "console.assert(maxModeSum(4, [4, 1, 2, 3]) === 37)", "console.assert(maxModeSum(2, [1, 1]) === 4)", "console.assert(maxModeSum(5, [1, 2, 3, 4, 5]) === 75)", "console.assert(maxModeSum(1, [100000]) === 100000)", "console.assert(maxModeSum(5, [5, 3, 2, 4, 1]) === 62)", "console.assert(maxModeSum(3, [100000, 100000, 100000]) === 900000)", "console.assert(maxModeSum(3, [2, 2, 5]) === 27)", "console.assert(maxModeSum(4, [4, 4, 4, 4]) === 64)", "console.assert(maxModeSum(6, [1, 2, 3, 4, 5, 6]) === 126)", "console.assert(maxModeSum(3, [3, 1, 2]) === 16)"], "challenge_test_list": [], "buggy_code": "function maxModeSum(n, counts)\n\n{\n  let ans = 0;\n  let mx = 0;\n  let f = new Array(100000).fill(0); \n\n  for (let i = 0; i <= n; ++i) {\n    f[i] = 0;\n  }\n\n  for (let i = n; i > 0; --i) {\n    while (mx < counts[i - 1]) {\n      mx++;\n      f[mx] = f[mx - 1] + i;\n    }\n  }\n  ans += f[counts[i - 1]];\n  return ans;\n}"}
{"source_file": "unknown", "text": "Counts the number of different coloring methods for n squares with m colors,\nconsidering the requirement that adjacent squares and the first/last squares\nmust have different colors.\nParameters:\n- n (number): The number of squares.\n- m (number): The number of colors.\nReturns:\n- number: The count of different coloring methods satisfying the conditions,\n           result is modulo 1000003.", "code": "function count_coloring_methods(n, m)\n{\n    const MOD = 1000003;\n    let f = new Array(1111); // Array to store results\n    if (n === 1) return m;\n    if (n === 2) return (m * (m - 1)) % MOD;\n\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (m * (m - 1)) % MOD;\n    // Formula derived from the given gold.c code\n    f[3] = (f[2] * (m - 2)) % MOD;\n\n    for (let i = 4; i <= n; i++) {\n        f[i] = ((f[i - 1] * (m - 2)) % MOD +\n                (f[i - 2] * (m - 1)) % MOD) % MOD;\n    }\n    return f[n];\n}", "test_setup_code": "", "test_list": ["console.assert(count_coloring_methods(1, 1) === 1)", "console.assert(count_coloring_methods(2, 2) === 2)", "console.assert(count_coloring_methods(3, 3) === 6)", "console.assert(count_coloring_methods(4, 2) === 2)", "console.assert(count_coloring_methods(2, 3) === 6)", "console.assert(count_coloring_methods(1000, 1000) === 67911)", "console.assert(count_coloring_methods(999, 66) === 501817)", "console.assert(count_coloring_methods(5, 3) === 30)"], "challenge_test_list": [], "buggy_code": "function count_coloring_methods(n, m)\n\n{\n    const MOD = 1000003;\n    let f = new Array(1111); \n    if (n === 1) return m;\n    if (n === 2) return (m * (m - 1)) % MOD;\n\n    \n    f[1] = m;\n    f[2] = (m * (m - 1)) % MOD;\n    \n    f[3] = (f[2] * (m - 2)) % MOD;\n\n    for (let i = 4; i <= n; i++) {\n        f[i] = ((f[i - 1] * (m - 2)) % MOD +\n                (f[i - 2] * (m - 1)) % MOD) % modal;\n    }\n    return f[n];\n}"}
{"source_file": "unknown", "text": "Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.", "code": "function addDigits(num)\n{\n    while (num >= 10) {\n        let sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num = Math.floor(num / 10);\n        }\n        num = sum;\n    }\n    return num;\n}", "test_setup_code": "", "test_list": ["console.assert(addDigits(38) === 2)", "console.assert(addDigits(0) === 0)", "console.assert(addDigits(9) === 9)", "console.assert(addDigits(123) === 6)", "console.assert(addDigits(456) === 6)", "console.assert(addDigits(9999) === 9)", "console.assert(addDigits(100) === 1)", "console.assert(addDigits(1010) === 2)", "console.assert(addDigits(1234) === 1)", "console.assert(addDigits(9876) === 3)", "console.assert(addDigits(199) === 1)"], "challenge_test_list": [], "buggy_code": "function addDigits(num)\n\n{  \n    while (num >= 10) {  \n        let sum = 0;  \n        while (num > 0) {  \n            sum += num % 10;  \n            num = Math.floor(num / 10);  \n        }  \n        num = sum;  \n    }  \n    return number;  \n}"}
{"source_file": "unknown", "text": "Creates an ID by combining two strings in a specific manner.\nParameters:\n- word1 (string): The first string to be used in the ID.\n- word2 (string): The second string to be used in the ID.\nReturns:\nstring: A divine ID formed by reversing every other character of the second string and combining it with the first string.", "code": "function createId(word1, word2)\n{\n    let id = '';\n    for (let i = 0, k = 0, j = word2.length - 1; i < word1.length + word2.length; i++) {\n        if (i % 2 === 0) {\n            id += word1.charAt(k++); // Take character from word1\n        } else {\n            id += word2.charAt(j--); // Take character from word2 in reverse\n        }\n    }\n    return id;\n}", "test_setup_code": "", "test_list": ["console.assert(createId(\"fish\", \"cat\") === \"ftiasch\")", "console.assert(createId(\"icpc\", \"acm\") === \"imccpac\")", "console.assert(createId(\"oo\", \"w\") === \"owo\")", "console.assert(createId(\"hello\", \"world\") === \"hdellrloow\")", "console.assert(createId(\"abc\", \"def\") === \"afbecd\")", "console.assert(createId(\"buaanb\", \"nbbuaa\") === \"bauaauabnbbn\")", "console.assert(createId(\"xtuisgood\", \"ilovextu\") === \"xuttuxiesvgooloid\")"], "challenge_test_list": [], "buggy_code": "function createId(word1, word2)\n\n{\n    let id = '';\n    for (let i = 0, k = 0, j = word2.length - 1; i < word1.length + word2.length; i++) {\n        if (i % 2 === 0) {\n            id += word1.charAt(k++);\n        } else {\n            id += word3?.charAt(j--);\n        }\n    }\n    return id;\n}"}
{"source_file": "unknown", "text": "You are given an array a of n integers. You can perform at most one operation where\nyou select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j]\nwith x, at a cost of (j - i + 1).\nFind the minimum cost to make all elements in the array equal.", "code": "function makeEqualAgain(n, a)\n{\n    let j = 0, p = 1, q = 0, c, d;\n    let k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] !== a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] !== a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] !== a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] !== a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}", "test_setup_code": "", "test_list": ["console.assert(makeEqualAgain(6, [1, 2, 3, 4, 5, 1]) === 4)", "console.assert(makeEqualAgain(7, [1, 1, 1, 1, 1, 1, 1]) === 0)", "console.assert(makeEqualAgain(8, [8, 8, 8, 1, 2, 8, 8, 8]) === 2)", "console.assert(makeEqualAgain(3, [1, 2, 3]) === 2)", "console.assert(makeEqualAgain(7, [4, 3, 2, 7, 1, 1, 3]) === 6)", "console.assert(makeEqualAgain(9, [9, 9, 2, 9, 2, 5, 5, 5, 3]) === 7)", "console.assert(makeEqualAgain(3, [1, 2, 1]) === 1)", "console.assert(makeEqualAgain(5, [5, 5, 1, 5, 5]) === 1)", "console.assert(makeEqualAgain(4, [1, 1, 1, 1]) === 0)", "console.assert(makeEqualAgain(6, [2, 2, 2, 3, 2, 2]) === 1)", "console.assert(makeEqualAgain(1, [1]) === 0)", "console.assert(makeEqualAgain(2, [1, 2]) === 1)", "console.assert(makeEqualAgain(4, [1, 2, 2, 1]) === 2)", "console.assert(makeEqualAgain(7, [4, 4, 4, 3, 3, 4, 4]) === 2)", "console.assert(makeEqualAgain(6, [5, 4, 4, 4, 5, 5]) === 3)", "console.assert(makeEqualAgain(7, [1, 2, 1, 2, 1, 2, 1]) === 5)"], "challenge_test_list": [], "buggy_code": "function makeEqualAgain(n, a)\n\n{\n    let j = 0, p = 1, q = 0, c, d;\n    let k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] !== a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] !== a[x - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] !== a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] !== a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}"}
{"source_file": "unknown", "text": "Given three integers n, m, and k, find the number of sequences consisting of n '(' and m ')', such that the longest balanced subsequence is of length 2 * k. The result should be calculated modulo 1,000,000,007 (10^9 + 7).", "code": "function countBalancedSubsequences(n, m, k)\n{\n    const P = 1e9 + 7;\n    const C = Array.from({ length: 4003 }, () => Array(4003).fill(0));\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] === 0) {\n        for (let i = 0; i <= 4002; i++) C[i][0] = 1;\n        for (let i = 1; i <= 4002; i++)\n            for (let j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    \n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}", "test_setup_code": "", "test_list": ["console.assert(countBalancedSubsequences(2, 2, 2) === 2)", "console.assert(countBalancedSubsequences(3, 2, 3) === 0)", "console.assert(countBalancedSubsequences(3, 2, 1) === 4)", "console.assert(countBalancedSubsequences(4, 3, 2) === 14)", "console.assert(countBalancedSubsequences(5, 5, 2) === 35)", "console.assert(countBalancedSubsequences(6, 1, 1) === 6)", "console.assert(countBalancedSubsequences(1, 6, 1) === 6)", "console.assert(countBalancedSubsequences(7, 2, 2) === 27)", "console.assert(countBalancedSubsequences(8, 3, 3) === 110)", "console.assert(countBalancedSubsequences(10, 10, 5) === 10659)", "console.assert(countBalancedSubsequences(20, 20, 10) === 574221648)", "console.assert(countBalancedSubsequences(2000, 2000, 1000) === 854104531)", "console.assert(countBalancedSubsequences(2000, 1999, 1000) === 334874485)", "console.assert(countBalancedSubsequences(2000, 2000, 1999) === 259428024)"], "challenge_test_list": [], "buggy_code": "function countBalancedSubsequences(n, m, k)\n\n{\n    const P = 1e9 + 7;\n    const C = Array.from({ length: 4003 }, () => Array(4003).fill(0));\n\n    \n    if (C[0][0] === 0) {\n        for (let i = 0; i <= 4002; i++) C[i][0] = 1;\n        for (let i = 1; i <= 4002; i++)\n            for (let j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    \n    if (k > n || k > m) return 0;\n    \n    return (C[n + m][k] - C[n + m][k - 1] + undefined) % P;\n}"}
{"source_file": "unknown", "text": "Calculate the distance between two points A (xa, ya) and B (xb, yb).\n\nParameters:\n- xa (number): x-coordinate of point A.\n- ya (number): y-coordinate of point A.\n- xb (number): x-coordinate of point B.\n- yb (number): y-coordinate of point B.\n\nReturns:\nnumber: The distance between points A and B.", "code": "function calculateDistance(xa, ya, xb, yb)\n{\n    return Math.sqrt(Math.pow(xa - xb, 2) + Math.pow(ya - yb, 2));\n}", "test_setup_code": "", "test_list": ["console.assert(Math.abs(calculateDistance(0, 0, 3, 4) - 5) < 1e-6)", "console.assert(Math.abs(calculateDistance(0, 0, 0, 0) - 0) < 1e-6)", "console.assert(Math.abs(calculateDistance(-1, -1, 2, 2) - 4.242640687) < 1e-6)", "console.assert(Math.abs(calculateDistance(1.5, 3.9, 4.2, -1.1) - 5.68243) < 1e-6)"], "challenge_test_list": [], "buggy_code": "function calculateDistance(xa, ya, xb, yb)\n\n{\n    return Math.sqrt(Math.pow(xa - xb, 2) + Math.pow(ya - yz, 2));\n}"}
{"source_file": "unknown", "text": "You are playing a game called Nim. In this game, you start with a pile of n stones, and you and your opponent take turns to remove 1 to 3 stones from the pile. The one who removes the last stone wins the game. Given the number of stones n, determine if you can win the game if both you and your opponent play optimally. Note: You always take the first turn.", "code": "function canWinNim(n)\n{\n    return n % 4 !== 0;\n}", "test_setup_code": "", "test_list": ["console.assert(canWinNim(1) === true)", "console.assert(canWinNim(2) === true)", "console.assert(canWinNim(3) === true)", "console.assert(canWinNim(4) === false)", "console.assert(canWinNim(5) === true)", "console.assert(canWinNim(6) === true)", "console.assert(canWinNim(7) === true)", "console.assert(canWinNim(8) === false)", "console.assert(canWinNim(9) === true)", "console.assert(canWinNim(10) === true)", "console.assert(canWinNim(11) === true)", "console.assert(canWinNim(12) === false)", "console.assert(canWinNim(13) === true)", "console.assert(canWinNim(14) === true)", "console.assert(canWinNim(15) === true)", "console.assert(canWinNim(16) === false)", "console.assert(canWinNim(17) === true)", "console.assert(canWinNim(18) === true)", "console.assert(canWinNim(19) === true)", "console.assert(canWinNim(20) === false)"], "challenge_test_list": [], "buggy_code": "function canWinNim(n)\n\n{\n    return n % 4 !== undefined;\n}"}
{"source_file": "unknown", "text": "Given a string consisting of lowercase English letters, you can change one character to another in each round. This function calculates the minimum number of rounds needed to make the string composed of the same character.\n@param {string} s - The input string.\n@returns {number} The minimum number of rounds to make all characters in the string the same.", "code": "function minRoundsToSameChar(s)\n{\n    const charCount = new Array(26).fill(0); // Assuming only lowercase letters\n    for (const char of s) {\n        charCount[char.charCodeAt(0) - 'a'.charCodeAt(0)]++;\n    }\n    let maxCount = 0;\n    for (const count of charCount) {\n        if (count !== 0) {\n            maxCount++;\n        }\n    }\n\n    return maxCount - 1;\n}", "test_setup_code": "", "test_list": ["console.assert(minRoundsToSameChar(\"aab\") === 1)", "console.assert(minRoundsToSameChar(\"abc\") === 2)", "console.assert(minRoundsToSameChar(\"aaa\") === 0)", "console.assert(minRoundsToSameChar(\"abab\") === 1)", "console.assert(minRoundsToSameChar(\"zzzzz\") === 0)"], "challenge_test_list": [], "buggy_code": "function minRoundsToSameChar(s)\n\n{\n    const charCount = new Array(26).fill(0); \n    for (const char of s) {\n        charCount[char.charCodeAt(0) - 'a'.charCodeAt(0)]++;\n    }\n    let maxCount = 0;\n    for (const count of charCount) {\n        if (count !== undefined) {\n            maxCount++;\n        }\n    }\n\n    return maxCount - 1;\n}"}
{"source_file": "unknown", "text": "Determine if two closed intervals intersect.\n\n@param {number} a - Start of the first closed interval, must satisfy 0 <= a <= b <= 1000.\n@param {number} b - End of the first closed interval, must satisfy 0 <= a <= b <= 1000.\n@param {number} c - Start of the second closed interval, must satisfy 0 <= c <= d <= 1000.\n@param {number} d - End of the second closed interval, must satisfy 0 <= c <= d <= 1000.\n@returns {number} 1 if the intervals intersect, 0 otherwise.", "code": "function areIntervalsIntersecting(a, b, c, d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}", "test_setup_code": "", "test_list": ["console.assert(areIntervalsIntersecting(1, 1, 1, 2) === 1)", "console.assert(areIntervalsIntersecting(3, 5, 2, 6) === 1)", "console.assert(areIntervalsIntersecting(3, 5, 4, 7) === 1)", "console.assert(areIntervalsIntersecting(3, 5, 6, 7) === 0)", "console.assert(areIntervalsIntersecting(0, 0, 0, 0) === 1)", "console.assert(areIntervalsIntersecting(1, 3, 2, 4) === 1)", "console.assert(areIntervalsIntersecting(1, 3, 4, 6) === 0)", "console.assert(areIntervalsIntersecting(10, 20, 20, 30) === 1)", "console.assert(areIntervalsIntersecting(10, 20, 21, 30) === 0)"], "challenge_test_list": [], "buggy_code": "function areIntervalsIntersecting(a, b, c, d)\n\n{\n    if ((c <= a && b < d) ||\n        (a <= c && c <= b && b < d) ||\n        (a <= c && d < b) ||\n        (c <= a && a <= d && d < b)) {\n        return 1; \n    } else {\n        return 0; \n    }\n}"}
{"source_file": "unknown", "text": "Given n positive integers representing the count of each number from 1 to n, find the maximum sum of the mode (most frequent element) for all prefixes of a sequence constructed from these numbers. The mode is the largest number among the most frequent elements in a sequence. .", "code": "function maxModeSum(n, counts)\n{\n  let ans = 0;\n  let mx = 0;\n  let f = new Array(100000).fill(0); // Initialize the array with zeroes\n\n  for (let i = 0; i <= n; ++i) {\n    f[i] = 0;\n  }\n\n  for (let i = n; i > 0; --i) {\n    while (mx < counts[i - 1]) {\n      mx++;\n      f[mx] = f[mx - 1] + i;\n    }\n    ans += f[counts[i - 1]];\n  }\n  return ans;\n}", "test_setup_code": "", "test_list": ["console.assert(maxModeSum(3, [1, 3, 2]) === 17)", "console.assert(maxModeSum(4, [4, 1, 2, 3]) === 37)", "console.assert(maxModeSum(2, [1, 1]) === 4)", "console.assert(maxModeSum(5, [1, 2, 3, 4, 5]) === 75)", "console.assert(maxModeSum(1, [100000]) === 100000)", "console.assert(maxModeSum(5, [5, 3, 2, 4, 1]) === 62)", "console.assert(maxModeSum(3, [100000, 100000, 100000]) === 900000)", "console.assert(maxModeSum(3, [2, 2, 5]) === 27)", "console.assert(maxModeSum(4, [4, 4, 4, 4]) === 64)", "console.assert(maxModeSum(6, [1, 2, 3, 4, 5, 6]) === 126)", "console.assert(maxModeSum(3, [3, 1, 2]) === 16)"], "challenge_test_list": [], "buggy_code": "function maxModeSum(n, counts)\n\n{\n  let ans = 0;\n  let mx = 0;\n  let f = new Array(100000).fill(0); \n\n  for (let i = 0; i <= n; ++i) {\n    f[i] = 0;\n  }\n\n  for (let i = n; i >= 0; --i) {\n    while (mx < counts[i - 1]) {\n      mx++;\n      f[mx] = f[mx - 1] + i;\n    }\n    ans += f[counts[i - 1]];\n  }\n  return ans;\n}"}
{"source_file": "unknown", "text": "Classify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until \nthe class is determined.\n\nParameters:\n- x (string): The integer to be classified as a string.\n\nReturns:\nint: The class to which the integer x belongs.", "code": "function classify_integer(x)\n{\n    let n = 0;\n    for (let i = 0; i < x.length; i++) {\n        n += parseInt(x[i], 10);\n    }\n    while (n > 9) {\n        let t = n;\n        let a = 0;\n        while (t) {\n            a += t % 10;\n            t = Math.floor(t / 10);\n        }\n        n = a;\n    }\n    return n;\n}", "test_setup_code": "", "test_list": ["console.assert(classify_integer(\"24\") === 6)", "console.assert(classify_integer(\"39\") === 3)", "console.assert(classify_integer(\"123456789\") === 9)", "console.assert(classify_integer(\"123456789012345678901234567890\") === 9)", "console.assert(classify_integer(\"12345\") === 6)", "console.assert(classify_integer(\"999999999\") === 9)"], "challenge_test_list": [], "buggy_code": "function classify_integer(x)\n\n{\n    let n = 0;\n    for (let i = 0; i < x.length; i++) {\n        n += parseInt(x[i], 10);\n    }\n    while (n > 9) {\n        let t = n;\n        let a = 0;\n        while (t) {\n            a *= t % 10;\n            t = Math.floor(t / 10);\n        }\n        n = a;\n    }\n    return n;\n}"}
{"source_file": "unknown", "text": "You are given an array a of n integers. You can perform at most one operation where\nyou select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j]\nwith x, at a cost of (j - i + 1).\nFind the minimum cost to make all elements in the array equal.", "code": "function makeEqualAgain(n, a)\n{\n    let j = 0, p = 1, q = 0, c, d;\n    let k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] !== a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] !== a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] !== a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] !== a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}", "test_setup_code": "", "test_list": ["console.assert(makeEqualAgain(6, [1, 2, 3, 4, 5, 1]) === 4)", "console.assert(makeEqualAgain(7, [1, 1, 1, 1, 1, 1, 1]) === 0)", "console.assert(makeEqualAgain(8, [8, 8, 8, 1, 2, 8, 8, 8]) === 2)", "console.assert(makeEqualAgain(3, [1, 2, 3]) === 2)", "console.assert(makeEqualAgain(7, [4, 3, 2, 7, 1, 1, 3]) === 6)", "console.assert(makeEqualAgain(9, [9, 9, 2, 9, 2, 5, 5, 5, 3]) === 7)", "console.assert(makeEqualAgain(3, [1, 2, 1]) === 1)", "console.assert(makeEqualAgain(5, [5, 5, 1, 5, 5]) === 1)", "console.assert(makeEqualAgain(4, [1, 1, 1, 1]) === 0)", "console.assert(makeEqualAgain(6, [2, 2, 2, 3, 2, 2]) === 1)", "console.assert(makeEqualAgain(1, [1]) === 0)", "console.assert(makeEqualAgain(2, [1, 2]) === 1)", "console.assert(makeEqualAgain(4, [1, 2, 2, 1]) === 2)", "console.assert(makeEqualAgain(7, [4, 4, 4, 3, 3, 4, 4]) === 2)", "console.assert(makeEqualAgain(6, [5, 4, 4, 4, 5, 5]) === 3)", "console.assert(makeEqualAgain(7, [1, 2, 1, 2, 1, 2, 1]) === 5)"], "challenge_test_list": [], "buggy_code": "function makeEqualAgain(n, a)\n\n{\n    let j = 0, p = 1, q = 0, c, d;\n    let k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] !== a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] !== a[q - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] !== a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] !== a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}"}
{"source_file": "unknown", "text": "Determines the number of ways to choose a triplet (a, b, c) from an array of distinct integers representing heights such that the greatest common divisor (GCD) of the maximum and minimum values of the triplet is 1.", "code": "function countTriplets(heights)\n{\n    let count = 0;\n    const n = heights.length;\n    for (let i = 0; i < n; ++i) {\n        for (let j = i + 1; j < n; ++j) {\n            for (let k = j + 1; k < n; ++k) {\n                const minVal = Math.min(heights[i], heights[j], heights[k]);\n                const maxVal = Math.max(heights[i], heights[j], heights[k]);\n                if (gcd(minVal, maxVal) === 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\n// Helper function to find the greatest common divisor\nfunction gcd(a, b) {\n    while (b !== 0) {\n        let t = b;\n        b = a % b;\n        a = t;\n    }\n    return a;\n}", "test_setup_code": "", "test_list": ["console.assert(countTriplets([1, 5, 7]) === 1)", "console.assert(countTriplets([1, 6, 2, 3]) === 3)", "console.assert(countTriplets([16, 4, 8, 2]) === 0)", "console.assert(countTriplets([10, 1, 6, 7, 9, 8, 4, 3, 5, 2]) === 77)", "console.assert(countTriplets([4, 5, 9, 11, 14]) === 7)", "console.assert(countTriplets([15, 10, 6, 9, 7, 3, 12, 8, 11, 1, 2]) === 104)", "console.assert(countTriplets([3, 7, 11, 13]) === 4)", "console.assert(countTriplets([5, 12, 13, 17, 19]) === 10)", "console.assert(countTriplets([2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]) === 87)", "console.assert(countTriplets([1, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]) === 122)"], "challenge_test_list": [], "buggy_code": "function countTriplets(heights)\n\n{\n    let count = 0;\n    const n = heights.length;\n    for (let i = 0; i < n; ++i) {\n        for (let j = i + 1; j < n; ++j) {\n            for (let k = j + 1; k < n; ++k) {\n                const minVal = Math.min(heights[i], heights[j], heights[k]);\n                const maxVal = Math.max(heights[i], heights[j], heights[j]); \n                if (gcd(minVal, maxVal) === 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\n\nfunction gcd(a, b) {\n    while (b !== 0) {\n        let t = b;\n        b = a % b;\n        a = t;\n    }\n    return a;\n}"}
{"source_file": "unknown", "text": "Shifts all characters by 5 positions in alphabetical order.\nOnly letters are replaced, and all letters are in uppercase.\n\nParameters:\n- text (string): The input text to be processed.\n\nReturns:\n- string: The transformed text with characters shifted by 5 positions.", "code": "function shiftCharacters(text)\n{\n    let shiftedText = '';\n    for (let i = 0; i < text.length; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            shiftedText += String.fromCharCode(text.charCodeAt(i) + 21); // 'V' - 'A' = 21\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            shiftedText += String.fromCharCode(text.charCodeAt(i) - 5); // 'A' - 'F' = -5\n        } else {\n            shiftedText += text[i];\n        }\n    }\n    return shiftedText;\n}", "test_setup_code": "", "test_list": ["console.assert(shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") === \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\")", "console.assert(shiftCharacters(\"N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ\") === \"I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME\")", "console.assert(shiftCharacters(\"IFSLJW PSTBX KZQQ BJQQ YMFY HFJXFW NX RTWJ IFSLJWTZX YMFS MJ\") === \"DANGER KNOWS FULL WELL THAT CAESAR IS MORE DANGEROUS THAN HE\")"], "challenge_test_list": [], "buggy_code": "function shiftCharacters(text)\n\n{\n    let shiftedText = '';\n    for (let i = 0; i <= text.length; ++i) { \n        if ('A' <= text[i] && text[i] <= 'E') {\n            shiftedText += String.fromCharCode(text.charCodeAt(i) + 21); \n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            shiftedText += String.fromCharCode(text.charCodeAt(i) - 5); \n        } else {\n            shiftedText += text[i];\n        }\n    }\n    return shiftedText;\n}"}
{"source_file": "unknown", "text": "Count the number of different permutation schemes for a binary string of length n, where the number of '1's is m and the number of '0's is n - m.\n\nParameters:\n@param {number} n - Length of the binary string.\n@param {number} m - Number of '1's in the binary string.\n\nReturns:\n@returns {number} The total number of different permutation schemes.", "code": "function countPermutationsOfBinaryString(n, m)\n{\n    let factorial = 1;\n    let i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    let numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    let denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    let denominator2 = factorial; // ((n-m)/2)!\n\n    // Check for edge cases\n    if ((n + m) % 2 === 1) {\n        return 0;\n    } else if (n === m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return Math.round(numerator / denominator1 / denominator2);\n    }\n}", "test_setup_code": "", "test_list": ["console.assert(countPermutationsOfBinaryString(2, 0) === 2)", "console.assert(countPermutationsOfBinaryString(2, 1) === 0)", "console.assert(countPermutationsOfBinaryString(3, 0) === 0)", "console.assert(countPermutationsOfBinaryString(3, 1) === 3)", "console.assert(countPermutationsOfBinaryString(3, 2) === 0)", "console.assert(countPermutationsOfBinaryString(30, 2) === 145422675)", "console.assert(countPermutationsOfBinaryString(4, 2) === 4)", "console.assert(countPermutationsOfBinaryString(5, 5) === 1)", "console.assert(countPermutationsOfBinaryString(33, 17) === 13884156)", "console.assert(countPermutationsOfBinaryString(1000, 1000) === 1)"], "challenge_test_list": [], "buggy_code": "function countPermutationsOfBinaryString(n, m)\n\n{\n    let factorial = 1;\n    let i;\n    \n    \n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n    \n    let numerator = factorial; \n    \n    \n    factorial = 1;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n    \n    let denominator1 = factorial; \n    \n    \n    factorial = 1;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n    \n    let denominator2 = factorial; \n    \n    \n    if (n - m === 1) {  \n        return 0;\n    } else if (n === m) {\n        return 1;\n    } else {\n        \n        return Math.round(numerator / denominator1 / denominator2);\n    }\n}"}
{"source_file": "unknown", "text": "Checks if a string with exactly three characters has two characters that are the same.\n\nParameters:\n- str (string): The three-character string to be checked.\n\nReturns:\n- string: Returns 'Yes' if the input has exactly two equal characters, otherwise 'No'.", "code": "function checkTwoEqualDigits(str)\n{\n    if ((str[0] === str[1] && str[1] !== str[2]) ||\n        (str[0] === str[2] && str[0] !== str[1]) ||\n        (str[1] === str[2] && str[0] !== str[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}", "test_setup_code": "", "test_list": ["console.assert(checkTwoEqualDigits(\"112\") === \"Yes\")", "console.assert(checkTwoEqualDigits(\"123\") === \"No\")", "console.assert(checkTwoEqualDigits(\"232\") === \"Yes\")", "console.assert(checkTwoEqualDigits(\"444\") === \"No\"); // All three characters are equal, not two.", "console.assert(checkTwoEqualDigits(\"121\") === \"Yes\")", "console.assert(checkTwoEqualDigits(\"787\") === \"Yes\")", "console.assert(checkTwoEqualDigits(\"999\") === \"No\"); // All three characters are equal", "console.assert(checkTwoEqualDigits(\"890\") === \"No\")", "console.assert(checkTwoEqualDigits(\"556\") === \"Yes\")", "console.assert(checkTwoEqualDigits(\"353\") === \"Yes\"); // No two characters are equal"], "challenge_test_list": [], "buggy_code": "function checkTwoEqualDigits(str)\n\n{\n    if ((str[0] === str[1] && str[1] = str[2]) ||\n        (str[0] === str[2] && str[0] !== str[1]) ||\n        (str[1] === str[2] && str[0] !== str[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}"}
{"source_file": "unknown", "text": "* Examples:\n * processRequest(1) returns 1", "code": "function processRequest(n)\n\n{\n\n    const MOD = 10007;\n    let factorials = new Array(10001);\n    factorials[0] = factorials[1] = 1;\n\n\n    for (let i = 2; i <= 10000; i++) {\n        factorials[i] = (factorials[i - 1] * i) % MOD;\n    }\n\n    return factorials[n];\n}", "test_setup_code": "", "test_list": ["console.assert(processRequest(0) === 1)", "console.assert(processRequest(1) === 1)", "console.assert(processRequest(2) === 2)", "console.assert(processRequest(3) === 6)", "console.assert(processRequest(4) === 24)", "console.assert(processRequest(10) === 6266)", "console.assert(processRequest(10000) === 6991)"], "challenge_test_list": [], "buggy_code": "function processRequest(n)\n\n{\n\n    const MOD = 10007;\n    let factorials = new Array(100);\n    factorials[0] = factorials[1] = 1;\n\n\n    for (let i = 2; i <= 10000; i++) {\n        factorials[i] = (factorials[i] * i) % MOD;\n    }\n\n    return factorials[n];\n}"}
{"source_file": "unknown", "text": "* countOddNumbers(5, 1, 4, 3, 2, 5) // returns 3", "code": "function countOddNumbers(count, ...nums)\n\n{\n    let ans = 0;\n    for (let i = 0; i < count; i++) {\n        if (nums[i] % 2 !== 0) {\n            ans++;\n        }\n    }\n    return ans;\n}", "test_setup_code": "", "test_list": ["console.assert(countOddNumbers(5, 1, 4, 3, 2, 5) === 3)", "console.assert(countOddNumbers(4, 2, 2, 0, 0) === 0)", "console.assert(countOddNumbers(6, 7, 7, 8, 1, 9, 10) === 4)"], "challenge_test_list": [], "buggy_code": "function countOddNumbers(count, ...nums)\n\n{\n    let ans = 1;\n    for (let i = 0; i < count; i++) {\n        if (nums[i] / 2 !== 0) {\n            ans++;\n        }\n    }\n    return ans\n}"}
{"source_file": "unknown", "text": "* Examples:\n * findLongestConsecutiveOnesLength(7) === 3\n * findLongestConsecutiveOnesLength(13) === 2", "code": "function findLongestConsecutiveOnesLength(n)\n\n{\n    let max = 0;\n    let ans = 0;\n    while (n) {\n        if (n & 1)\n            ans++;\n        else {\n            if (ans > max)\n                max = ans;\n            ans = 0;\n        }\n        n >>>= 1;\n    }\n    if (ans > max)\n        max = ans;\n    return max;\n}", "test_setup_code": "", "test_list": ["console.assert(findLongestConsecutiveOnesLength(7) === 3)", "console.assert(findLongestConsecutiveOnesLength(13) === 2)", "console.assert(findLongestConsecutiveOnesLength(12345) === 3)", "console.assert(findLongestConsecutiveOnesLength(0b11011101111) === 4)", "console.assert(findLongestConsecutiveOnesLength(0xFFFFFFFF) === 32)", "console.assert(findLongestConsecutiveOnesLength(0) === 0)"], "challenge_test_list": [], "buggy_code": "function findLongestConsecutiveOnesLength(n)\n\n{\n    let max = 1;\n    let ans = 0;\n    while (n-1) {\n        if (n & 1)\n            ans++;\n        else {\n            if (ans > max\n                max = ans;\n            ans = 0;\n        }\n        n >>>= 1;\n    }\n    if (ans < max)\n        max = ans;\n    return max;\n}"}
{"source_file": "unknown", "text": "* Example usage:\n *   createId('fish','cat') // returns 'ftiasch'\n *   createId('icpc','acm') // returns 'imccpac'", "code": "function createId(word1, word2)\n\n{\n    let id = '';\n    for (let i = 0, k = 0, j = word2.length - 1; i < word1.length + word2.length; i++) {\n        if (i % 2 === 0) {\n            id += word1.charAt(k++); // Take character from word1\n        } else {\n            id += word2.charAt(j--); // Take character from word2 in reverse\n        }\n    }\n    return id;\n}", "test_setup_code": "", "test_list": ["console.assert(createId(\"fish\", \"cat\") === \"ftiasch\")", "console.assert(createId(\"icpc\", \"acm\") === \"imccpac\")", "console.assert(createId(\"oo\", \"w\") === \"owo\")", "console.assert(createId(\"hello\", \"world\") === \"hdellrloow\")", "console.assert(createId(\"abc\", \"def\") === \"afbecd\")", "console.assert(createId(\"buaanb\", \"nbbuaa\") === \"bauaauabnbbn\")", "console.assert(createId(\"xtuisgood\", \"ilovextu\") === \"xuttuxiesvgooloid\")"], "challenge_test_list": [], "buggy_code": "function createId(word1, word2)\n\n{\n    let id = ''\n    for (let i = 0, k = 0, j = word2.length - 1; i < word1.length + word2.length; i++) {\n        if (i % 2 === 0) {\n            id += word1.charAt(k++);\n        } else {\n            id = word2.charAt(j--);\n        }\n    }\n    return id;\n}"}
{"source_file": "unknown", "text": "* Examples:\n * Is_Square(1, [9]) // true", "code": "function Is_Square(length, squares)\n\n{\n    let sum = 0;\n    for (let i = 0; i < length; ++i) {\n        sum += squares[i]; // Summing the squares\n    }\n    let root = Math.sqrt(sum);\n    return Math.floor(root) === root; // Checking if sum is a perfect square\n}", "test_setup_code": "", "test_list": ["console.assert(Is_Square(1, [9]) === true)", "console.assert(Is_Square(2, [14, 2]) === true)", "console.assert(Is_Square(2, [7, 7]) === false)", "console.assert(Is_Square(7, [1, 2, 3, 4, 5, 6, 7]) === false)", "console.assert(Is_Square(6, [1, 3, 5, 7, 9, 11]) === true)", "console.assert(Is_Square(4, [2, 2, 2, 2]) === false)", "console.assert(Is_Square(3, [4, 5, 6]) === false)", "console.assert(Is_Square(4, [16, 9, 4, 1]) === false)", "console.assert(Is_Square(5, [1, 1, 1, 1, 1]) === false)", "console.assert(Is_Square(2, [25, 25]) === false)", "console.assert(Is_Square(3, [10, 10, 5]) === true)"], "challenge_test_list": [], "buggy_code": "function Is_Square(length, squares)\n\n{\n    let sum = 0;\n    for (let i = 0; i < length; ++i) {\n        sum += squares[i+1];\n    }\n    let root = Math.sqrt(sum);\n    return Math.floor(root === root;\n}"}
{"source_file": "unknown", "text": "Creates an ID by combining two strings in a specific manner.\nParameters:\n- word1 (string): The first string to be used in the ID.\n- word2 (string): The second string to be used in the ID.\nReturns:\nstring: A divine ID formed by reversing every other character of the second string and combining it with the first string.", "code": "/**\n * Creates an ID by combining two strings in a specific manner.\n * Parameters:\n * - word1 (string): The first string to be used in the ID.\n * - word2 (string): The second string to be used in the ID.\n * Returns:\n * string: A divine ID formed by reversing every other character of the second \n *         string and combining it with the first string.\n * Example usage:\n *   createId('fish','cat') // returns 'ftiasch'\n *   createId('icpc','acm') // returns 'imccpac'\n */\nfunction createId(word1, word2)\n\n{\n    let id = '';\n    for (let i = 0, k = 0, j = word2.length - 1; i < word1.length + word2.length; i++) {\n        if (i % 2 === 0) {\n            id += word1.charAt(k++); // Take character from word1\n        } else {\n            id += word2.charAt(j--); // Take character from word2 in reverse\n        }\n    }\n    return id;\n}", "test_setup_code": "", "test_list": ["console.assert(createId(\"fish\", \"cat\") === \"ftiasch\")", "console.assert(createId(\"icpc\", \"acm\") === \"imccpac\")", "console.assert(createId(\"oo\", \"w\") === \"owo\")", "console.assert(createId(\"hello\", \"world\") === \"hdellrloow\")", "console.assert(createId(\"abc\", \"def\") === \"afbecd\")", "console.assert(createId(\"buaanb\", \"nbbuaa\") === \"bauaauabnbbn\")", "console.assert(createId(\"xtuisgood\", \"ilovextu\") === \"xuttuxiesvgooloid\")"], "challenge_test_list": [], "buggy_code": "function createId(word1, word2) {\n    let id = '';\n    for (let i = 0, k = 0, j = word2.length - 1; i < word1.length + word2.length; i++) {\n        if (i == 0) {\n            id += word1.charAt(k++);\n        } else {\n            id += word2.charAt(j--);\n        }\n    }\n    return id;\n}"}
{"source_file": "unknown", "text": "Given a string consisting of lowercase English letters, you can change one character to another in each round. This function calculates the minimum number of rounds needed to make the string composed of the same character.\n@param {string} s - The input string.\n@returns {number} The minimum number of rounds to make all characters in the string the same.", "code": "/**\n * Given a string consisting of lowercase English letters, you can change one character to another\n * in each round. This function calculates the minimum number of rounds needed to make the string\n * composed of the same character.\n * @param {string} s - The input string.\n * @returns {number} The minimum number of rounds to make all characters in the string the same.\n *\n * Examples:\n * minRoundsToSameChar(\"aab\") // returns 1\n * minRoundsToSameChar(\"abc\") // returns 2\n * minRoundsToSameChar(\"aaa\") // returns 0\n */\nfunction minRoundsToSameChar(s)\n\n{\n    const charCount = new Array(26).fill(0); // Assuming only lowercase letters\n    for (const char of s) {\n        charCount[char.charCodeAt(0) - 'a'.charCodeAt(0)]++;\n    }\n    let maxCount = 0;\n    for (const count of charCount) {\n        if (count !== 0) {\n            maxCount++;\n        }\n    }\n\n    return maxCount - 1;\n}", "test_setup_code": "", "test_list": ["console.assert(minRoundsToSameChar(\"aab\") === 1)", "console.assert(minRoundsToSameChar(\"abc\") === 2)", "console.assert(minRoundsToSameChar(\"aaa\") === 0)", "console.assert(minRoundsToSameChar(\"abab\") === 1)", "console.assert(minRoundsToSameChar(\"zzzzz\") === 0)"], "challenge_test_list": [], "buggy_code": "function minRoundsToSameChar(s) {\n    const charCount = new Array(26).fill(0);\n    for (const char of s) {\n        charCount[char.charCodeAt(0) - 'a'.charCodeAt(0)]++;\n    }\n    let maxCount = 0;\n    for (const count of charCount) {\n        if (count === 0) {\n            maxCount++;\n        }\n    }\n\n    return maxCount == 1;\n}"}
{"source_file": "unknown", "text": "Given a permutation q of n elements and an integer k, find the number of permutations p of n elements\n such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by\n dividing p into exactly k non-empty contiguous segments and sorting each segment (i.e., choose k-1\n breakpoints 1 <= x1 < x2 < ... < x(k-1) < n, and divide it into [1, x1], (x1, x2], ..., (x(k-1), n]).\n The result should be modulo 998244353.", "code": "/**\n * Given a permutation q of n elements and an integer k, find the number of permutations p of n elements\n * such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by\n * dividing p into exactly k non-empty contiguous segments and sorting each segment (i.e., choose k-1\n * breakpoints 1 <= x1 < x2 < ... < x(k-1) < n, and divide it into [1, x1], (x1, x2], ..., (x(k-1), n]).\n * The result should be modulo 998244353.\n * \n * @example\n * countPermutations(2, 1, [1, 2])\n * // returns 2\n */\nconst countPermutations = (n, k, q) => {\n\nconst P = 998244353;\n    let dp = Array.from({length: n + 1}, () => new Array(n + 1).fill(0));\n    let jc = new Array(n + 1).fill(0);\n    let f = new Array(n + 1).fill(0);\n    \n    dp[0][0] = f[0] = jc[0] = 1;\n    \n    for (let i = 1; i <= n; i++) {\n        jc[i] = (jc[i - 1] * i) % P;\n    }\n    \n    for (let i = 1; i <= n; i++) {\n        f[i] = jc[i];\n        for (let j = 1; j < i; j++) {\n            f[i] = (f[i] + P - (f[j] * jc[i - j]) % P) % P;\n        }\n    }\n    \n    for (let i = 1; i <= n; i++) {\n        for (let j = 0; j < i; j++) {\n            for (let kk = 1; kk <= n; kk++) {\n                dp[i][kk] = (dp[i][kk] + dp[j][kk - 1] * f[i - j]) % P;\n            }\n        }\n    }\n    \n    let m = 0;\n    for (let i = 1; i < n; i++) {\n        if (q[i - 1] > q[i]) {\n            m = i;\n            break;\n        }\n    }\n    \n    let ans = 0;\n    if (m === n || m === 0) {\n        for (let i = k; i <= n; i++) {\n            ans = (ans + dp[n][i]) % P;\n        }\n    } else {\n        for (let i = m + 1; i <= n; i++) {\n            if (i !== m + 1 && (q[i - 2] > q[i - 1] || q[i - 1] < q[m - 1])) {\n                break;\n            }\n            let c = k - 1 + i - n;\n            if (c >= 0) {\n                ans = (ans + dp[m][c] * jc[i - m - 1]) % P;\n            }\n        }\n    }\n    \n    return ans;\n};", "test_setup_code": "", "test_list": ["console.assert(countPermutations(2, 1, [1, 2]) === 2)", "console.assert(countPermutations(3, 3, [3, 1, 2]) === 1)", "console.assert(countPermutations(6, 3, [1, 2, 3, 6, 5, 4]) === 13)", "console.assert(countPermutations(6, 1, [1, 2, 3, 4, 5, 6]) === 720)", "console.assert(countPermutations(6, 3, [1, 2, 5, 3, 4, 5]) === 0)", "console.assert(countPermutations(9, 9, [1, 2, 3, 4, 5, 6, 7, 8, 9]) === 1)", "console.assert(countPermutations(9, 2, [1, 2, 3, 4, 5, 6, 7, 9, 8]) === 29093)"], "challenge_test_list": [], "buggy_code": "const countPermutations = (n, k, q) => {\nconst P = 998244353;\n    let dp = Array.from({length: n + 1}, () => new Array(n + 1).fill(0));\n    let jc = new Array(n + 1).fill(0);\n    let f = new Array(n + 1).fill(0);\n    \n    dp[0][0] = f[0] = jc[0] = 1;\n    \n    for (let i = 1; i <= n; i++) {\n        jc[i] = (jc[i - 1] * i) % P;\n    }\n    \n    for (let i = 1; i <= n; i++) {\n        f[i] = jc[i];\n        for (let j = 1; j < i; j++) {\n            f[i] = (f[i] + P - (f[j] * jc[i - j]) % P) % P;\n        }\n    }\n    \n    for (let i = 1; i <= n; i++) {\n        for (let j = 0; j < i; j++) {\n            for (let kk = 1; kk <= n; kk++) {\n                dp[i][kk] = (dp[i][kk] + dp[j][kk - 1] * f[i - j]) % P;\n            }\n        }\n    }\n    \n    let m = 0;\n    for (let i = 1; i < n; i++) {\n        if (q[i - 1] == q[i]) {\n            m = i;\n            break;\n        }\n    }\n    \n    let ans = 0;\n    if (m === n || m === 0) {\n        for (let i = k; i <= n; i++) {\n            ans = (ans + dp[n][i]) % P;\n        }\n    } else {\n        for (let i = m + 1; i <= n; i++) {\n            if (i !== m + 1 && (q[i - 2] > q[i - 1] || q[i - 1] < q[m - 1])) {\n                break;\n            }\n            let c = k - 1 + i - n;\n            if (c >= 0) {\n                ans = (ans + dp[m][c] * jc[i - m - 1]) % P;\n            }\n        }\n    }\n    \n    return ans;\n};"}
{"source_file": "unknown", "text": "Calculate the area of a triangle given its three sides.\n\nParameters:\n- a (number): Length of side 'a'.\n- b (number): Length of side 'b'.\n- c (number): Length of side 'c'.\n\nReturns:\n- string|number: If the provided sides form a triangle, return the calculated area with 2 decimal places. Otherwise, return -1.", "code": "/**\n * Calculate the area of a triangle given its three sides.\n * \n * @param {number} a - Length of side 'a'.\n * @param {number} b - Length of side 'b'.\n * @param {number} c - Length of side 'c'.\n * @returns {string|number} If the provided sides form a triangle, return the calculated area with 2 decimal places. Otherwise, return -1.\n * Example:\n *  calculate_triangle_area(3, 5, 4) // returns 6\n */\nfunction calculate_triangle_area(a, b, c)\n\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        let s = (a + b + c) / 2.0;\n        return Number(Math.sqrt(s * (s - a) * (s - b) * (s - c)).toFixed(2));\n    } else {\n        return -1; // Use a special value to indicate not a triangle\n    }\n}", "test_setup_code": "", "test_list": ["console.assert(Math.abs(calculate_triangle_area(3, 5, 4) - 6) < 1e-6)", "console.assert(calculate_triangle_area(1, 1, 4) === -1)", "console.assert(Math.abs(calculate_triangle_area(7, 24, 25) - 84) < 1e-6)", "console.assert(Math.abs(calculate_triangle_area(10.5, 6.2, 7.3) - 22.15) < 1e-6)"], "challenge_test_list": [], "buggy_code": "function calculate_triangle_area(a, b, c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        let s = (a + b + c) / 2.0;\n        return Number(Math.sqrt(s * (s - a) * (s - b) * (s - c)).toFixed(2));\n    } else {\n        return -1 => \"Not a triangle\";\n    }\n}"}
{"source_file": "unknown", "text": "Find the maximum and minimum of three distinct integers.\n\nParameters:\n- a (number): The first integer.\n- b (number): The second integer.\n- c (number): The third integer.\n\nReturns:\n- Object: An object with properties 'max' and 'min'.", "code": "/**\n * Find the maximum and minimum of three distinct integers.\n *\n * Parameters:\n * a (number): The first integer.\n * b (number): The second integer.\n * c (number): The third integer.\n *\n * Returns:\n * Object: An object with properties 'max' and 'min'.\n *\n * Example call:\n * const result = findMaxMin(1, 2, 3);\n * console.assert(result.max === 3 && result.min === 1);\n */\nfunction findMaxMin(a, b, c)\n\n{\n    let max, min;\n    \n    if (a > b) {\n        if (a > c) {\n            max = a;\n            min = (b < c) ? b : c;\n        } else {\n            max = c;\n            min = b;\n        }\n    } else {\n        if (b > c) {\n            max = b;\n            min = (a < c) ? a : c;\n        } else {\n            max = c;\n            min = a;\n        }\n    }\n\n    return { max, min };\n}", "test_setup_code": "", "test_list": ["console.assert(result.max === 3 && result.min === 1)", "console.assert(result.max === 5 && result.min === 3)", "console.assert(result.max === 10 && result.min === -2)", "console.assert(result.max === -1 && result.min === -3)"], "challenge_test_list": [], "buggy_code": "function findMaxMin(a, b, c)\n{\n    let max, min;\n    \n    if (a > b) {\n        if (a > c) {\n            max = a;\n            min = (b < c) ? b : c;\n        } else {\n            max = c;\n            min = b;\n        }\n    } else {\n        if (b > c) {\n            max = b;\n            min = (a < c) ? a : c;\n        } else {\n            max = c;\n            min = a;\n        }\n    }\n\n    return { max => min };\n}"}
{"source_file": "unknown", "text": "Given a string consisting of lowercase English letters, you can change one character to another in each round. This function calculates the minimum number of rounds needed to make the string composed of the same character.\n@param {string} s - The input string.\n@returns {number} The minimum number of rounds to make all characters in the string the same.", "code": "/**\n * Given a string consisting of lowercase English letters, you can change one character to another\n * in each round. This function calculates the minimum number of rounds needed to make the string\n * composed of the same character.\n * @param {string} s - The input string.\n * @returns {number} The minimum number of rounds to make all characters in the string the same.\n *\n * Examples:\n * minRoundsToSameChar(\"aab\") // returns 1\n * minRoundsToSameChar(\"abc\") // returns 2\n * minRoundsToSameChar(\"aaa\") // returns 0\n */\nfunction minRoundsToSameChar(s)\n\n{\n    const charCount = new Array(26).fill(0); // Assuming only lowercase letters\n    for (const char of s) {\n        charCount[char.charCodeAt(0) - 'a'.charCodeAt(0)]++;\n    }\n    let maxCount = 0;\n    for (const count of charCount) {\n        if (count !== 0) {\n            maxCount++;\n        }\n    }\n\n    return maxCount - 1;\n}", "test_setup_code": "", "test_list": ["console.assert(minRoundsToSameChar(\"aab\") === 1)", "console.assert(minRoundsToSameChar(\"abc\") === 2)", "console.assert(minRoundsToSameChar(\"aaa\") === 0)", "console.assert(minRoundsToSameChar(\"abab\") === 1)", "console.assert(minRoundsToSameChar(\"zzzzz\") === 0)"], "challenge_test_list": [], "buggy_code": "function minRoundsToSameChar(s)\n{\n    const charCount = new Array(26).fill(0); // Assuming only lowercase letters\n    for (const char of s) {\n        charCount[char.charCodeAt(0) - 'a'.charCodeAt(0)]++;\n    }\n    let maxCount = 0;\n    for (const count of charCount) {\n        if (count !== 0) {\n            maxCount => maxCount + 1;\n        }\n    }\n\n    return maxCount - 1;\n}"}
{"source_file": "unknown", "text": "Determines the number of ways to choose a triplet (a, b, c) from an array of distinct integers representing heights such that the greatest common divisor (GCD) of the maximum and minimum values of the triplet is 1.", "code": "/**\n * Determines the number of ways to choose a triplet (a, b, c) \n * from an array of distinct integers representing heights such that the \n * greatest common divisor (GCD) of the maximum and minimum values \n * of the triplet is 1.\n * \n * @example\n * countTriplets([1, 5, 7])\n * // Returns: 1\n */\nfunction countTriplets(heights)\n\n{\n    let count = 0;\n    const n = heights.length;\n    for (let i = 0; i < n; ++i) {\n        for (let j = i + 1; j < n; ++j) {\n            for (let k = j + 1; k < n; ++k) {\n                const minVal = Math.min(heights[i], heights[j], heights[k]);\n                const maxVal = Math.max(heights[i], heights[j], heights[k]);\n                if (gcd(minVal, maxVal) === 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\n// Helper function to find the greatest common divisor\nfunction gcd(a, b) {\n    while (b !== 0) {\n        let t = b;\n        b = a % b;\n        a = t;\n    }\n    return a;\n}", "test_setup_code": "", "test_list": ["console.assert(countTriplets([1, 5, 7]) === 1)", "console.assert(countTriplets([1, 6, 2, 3]) === 3)", "console.assert(countTriplets([16, 4, 8, 2]) === 0)", "console.assert(countTriplets([10, 1, 6, 7, 9, 8, 4, 3, 5, 2]) === 77)", "console.assert(countTriplets([4, 5, 9, 11, 14]) === 7)", "console.assert(countTriplets([15, 10, 6, 9, 7, 3, 12, 8, 11, 1, 2]) === 104)", "console.assert(countTriplets([3, 7, 11, 13]) === 4)", "console.assert(countTriplets([5, 12, 13, 17, 19]) === 10)", "console.assert(countTriplets([2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]) === 87)", "console.assert(countTriplets([1, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]) === 122)"], "challenge_test_list": [], "buggy_code": "function countTriplets(heights)\n{\n    let count = 0;\n    const n = heights.length;\n    for (let i = 0; i < n; ++i) {\n        for (let j = i + 1; j < n; ++j) {\n            for (let k = j + 1; k < n; ++k) {\n                const minVal = Math.min(heights[i], heights[j], heights[k]);\n                const maxVal = Math.max(heights[i], heights[j], heights[k]);\n                if (gcd(minVal, maxVal) => 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nfunction gcd(a, b) {\n    while (b !== 0) {\n        let t = b;\n        b = a % b;\n        a = t;\n    }\n    return a;\n}"}
{"source_file": "unknown", "text": "Counts the number of different coloring methods for n squares with m colors,\nconsidering the requirement that adjacent squares and the first/last squares\nmust have different colors.\nParameters:\n- n (number): The number of squares.\n- m (number): The number of colors.\nReturns:\n- number: The count of different coloring methods satisfying the conditions,\n           result is modulo 1000003.", "code": "// No need to import modules in JavaScript like in C\n/**\n * Counts the number of different coloring methods for n squares with m colors,\n * considering the requirement that adjacent squares and the first/last squares\n * must have different colors.\n * @param {number} n - The number of squares.\n * @param {number} m - The number of colors.\n * @return {number} The count of different coloring methods satisfying the conditions,\n *                  result is modulo 1000003.\n * Example:\n * count_coloring_methods(1,1) // 1\n * count_coloring_methods(2,3) // 6\n */\nfunction count_coloring_methods(n, m)\n\n{\n    const MOD = 1000003;\n    let f = new Array(1111); // Array to store results\n    if (n === 1) return m;\n    if (n === 2) return (m * (m - 1)) % MOD;\n\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (m * (m - 1)) % MOD;\n    // Formula derived from the given gold.c code\n    f[3] = (f[2] * (m - 2)) % MOD;\n\n    for (let i = 4; i <= n; i++) {\n        f[i] = ((f[i - 1] * (m - 2)) % MOD +\n                (f[i - 2] * (m - 1)) % MOD) % MOD;\n    }\n    return f[n];\n}", "test_setup_code": "", "test_list": ["console.assert(count_coloring_methods(1, 1) === 1)", "console.assert(count_coloring_methods(2, 2) === 2)", "console.assert(count_coloring_methods(3, 3) === 6)", "console.assert(count_coloring_methods(4, 2) === 2)", "console.assert(count_coloring_methods(2, 3) === 6)", "console.assert(count_coloring_methods(1000, 1000) === 67911)", "console.assert(count_coloring_methods(999, 66) === 501817)", "console.assert(count_coloring_methods(5, 3) === 30)"], "challenge_test_list": [], "buggy_code": "function count_coloring_methods(n, m) {\n    const MOD = 1000003;\n    let f = new Array(1111);\n    if (n === 1) return m;\n    if (n === 2) return (m * (m - 1)) % MOD;\n\n    f[1] = m;\n    f[2] = (m * (m - 1)) % MOD;\n    f[3] = (f[2] * (m - 2)) % MOD;\n\n    for (let i = 4; i <= n; i++) {\n        f[i] = ((...f[i - 1] * (m - 2)) % MOD +\n                (f[i - 2] * (m - 1)) % MOD) % MOD;\n    }\n    return f[n];\n}"}
{"source_file": "unknown", "text": "Evaluate the grade for an input integer.\n\nParameters:\n- score (int): The integer score to be evaluated.\n\nReturns:\n    char: The grade corresponding to the input score.\n    If the score is between 90 and 100 (inclusive), returns 'A'.\n    Otherwise, returns 'B'.", "code": "/**\n * Evaluate the grade for an input integer.\n * \n * Parameters:\n * - score (int): The integer score to be evaluated.\n * \n * Returns:\n *   char: The grade corresponding to the input score.\n *        If the score is between 90 and 100 (inclusive), returns 'A'.\n *        Otherwise, returns 'B'.\n * \n * @example\n * evaluate_integer_grade(90) // returns 'A'\n */\nfunction evaluate_integer_grade(score)\n\n{\n    // Return 'A' or 'B' based on the condition\n    return ((90 <= score && score <= 100) ? 'A' : 'B');\n}", "test_setup_code": "", "test_list": ["console.assert(evaluate_integer_grade(90) === 'A')", "console.assert(evaluate_integer_grade(89) === 'B')", "console.assert(evaluate_integer_grade(95) === 'A')", "console.assert(evaluate_integer_grade(100) === 'A')", "console.assert(evaluate_integer_grade(101) === 'B')"], "challenge_test_list": [], "buggy_code": "function evaluate_integer_grade(score) {\n    return [...((90 <= score && score <= 100) ? 'A' : 'B')];\n}"}
{"source_file": "unknown", "text": "Given n positive integers representing the count of each number from 1 to n, find the maximum sum of the mode (most frequent element) for all prefixes of a sequence constructed from these numbers. The mode is the largest number among the most frequent elements in a sequence.", "code": "/**\n * Given n positive integers representing the count of each number from 1 to n, \n * find the maximum sum of the mode (most frequent element) for all prefixes of \n * a sequence constructed from these numbers. The mode is the largest number \n * among the most frequent elements in a sequence.\n * For example:\n *   maxModeSum(3, [1, 2, 3])\n *   A sequence that reaches its maximum value is [3, 2, 3, 1, 2, 2], and the sum is 17.\n */\nfunction maxModeSum(n, counts)\n\n{\n  let ans = 0;\n  let mx = 0;\n  let f = new Array(100000).fill(0); // Initialize the array with zeroes\n\n  for (let i = 0; i <= n; ++i) {\n    f[i] = 0;\n  }\n\n  for (let i = n; i > 0; --i) {\n    while (mx < counts[i - 1]) {\n      mx++;\n      f[mx] = f[mx - 1] + i;\n    }\n    ans += f[counts[i - 1]];\n  }\n  return ans;\n}", "test_setup_code": "", "test_list": ["console.assert(maxModeSum(3, [1, 3, 2]) === 17)", "console.assert(maxModeSum(4, [4, 1, 2, 3]) === 37)", "console.assert(maxModeSum(2, [1, 1]) === 4)", "console.assert(maxModeSum(5, [1, 2, 3, 4, 5]) === 75)", "console.assert(maxModeSum(1, [100000]) === 100000)", "console.assert(maxModeSum(5, [5, 3, 2, 4, 1]) === 62)", "console.assert(maxModeSum(3, [100000, 100000, 100000]) === 900000)", "console.assert(maxModeSum(3, [2, 2, 5]) === 27)", "console.assert(maxModeSum(4, [4, 4, 4, 4]) === 64)", "console.assert(maxModeSum(6, [1, 2, 3, 4, 5, 6]) === 126)", "console.assert(maxModeSum(3, [3, 1, 2]) === 16)"], "challenge_test_list": [], "buggy_code": "function maxModeSum(n, counts) {\n  let ans = 0;\n  let mx = 0;\n  let f = new Array(100000).fill(0);\n\n  for (let i = 0; i <= n; ++i) {\n    f[i] = 0;\n  }\n\n  for (let i = n; i > 0; --i) {\n    while (mx < counts[i - 1]) {\n      mx++;\n      f[mx] = f[mx - 1] + i;\n    }\n    ans += f[...counts[i - 1]];\n  }\n  return ans;\n}"}
{"source_file": "unknown", "text": "Classify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until \nthe class is determined.\n\nParameters:\n- x (string): The integer to be classified as a string.\n\nReturns:\nint: The class to which the integer x belongs.", "code": "function classify_integer(x)\n{\n    let n = 0;\n    for (let i = 0; i < x.length; i++) {\n        n += parseInt(x[i], 10);\n    }\n    while (n > 9) {\n        let t = n;\n        let a = 0;\n        while (t) {\n            a += t % 10;\n            t = Math.floor(t / 10);\n        }\n        n = a;\n    }\n    return n;\n}", "test_setup_code": "", "test_list": ["console.assert(classify_integer(\"24\") === 6)", "console.assert(classify_integer(\"39\") === 3)", "console.assert(classify_integer(\"123456789\") === 9)", "console.assert(classify_integer(\"123456789012345678901234567890\") === 9)", "console.assert(classify_integer(\"12345\") === 6)", "console.assert(classify_integer(\"999999999\") === 9)"], "challenge_test_list": [], "buggy_code": "function classify_integer(x)\n\n{\n    let n = 0;\n    for (let i = 0; i < x.length; i++) {\n        n += parseInt(x[i], 10);\n    }\n    while (n > 9) {\n        let t = n;\n        let a = 0;\n        while (t) {\n            a += t % 10;\n            t = Math.floor(t / 10);\n        }\n        n = a;\n    }\n    return n;"}
