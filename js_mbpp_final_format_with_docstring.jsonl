{"task_id": "MBPP_JS/classify_integer", "prompt": "def classify_integer(...) :\n    \"\"\"\n    Classify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until \nthe class is determined.\n\nParameters:\n- x (string): The integer to be classified as a string.\n\nReturns:\nint: The class to which the integer x belongs.\n    \"\"\"", "entry_point": "classify_integer", "test": "def check(candidate):\n    console.assert(classify_integer(\"24\") === 6)\n    console.assert(classify_integer(\"39\") === 3)\n    console.assert(classify_integer(\"123456789\") === 9)\n    console.assert(classify_integer(\"123456789012345678901234567890\") === 9)\n    console.assert(classify_integer(\"12345\") === 6)\n    console.assert(classify_integer(\"999999999\") === 9)\ncheck(classify_integer)\n", "given_tests": ["console.assert(classify_integer(\"24\") === 6)"], "solution": "function classify_integer(x)\n/**\n Classify the integer x based on the following method:\n If x is a single-digit number, x belongs to its own class.\n Otherwise, sum the digits of x, get a new x, and iterate until\n the class is determined.\n \n Parameters:\n - x (string): The integer to be classified as a string.\n \n Returns:\n int: The class to which the integer x belongs.\n*/\n{\n    let n = 0;\n    for (let i = 0; i < x.length; i++) {\n        n += parseInt(x[i], 10);\n    }\n    while (n > 9) {\n        let t = n;\n        let a = 0;\n        while (t) {\n            a += t % 10;\n            t = Math.floor(t / 10);\n        }\n        n = a;\n    }\n    return n;\n}"}
{"task_id": "MBPP_JS/decodeNumbers", "prompt": "def decodeNumbers(...) :\n    \"\"\"\n    Decode a series of numbers to reveal the pattern and understand the actual values each digit represents. The patterns are as follows: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nParameters:\n- dataStr (string): A string representing a series of numbers. The length does not exceed 100 characters.\n\nReturns:\n- number: The result corresponding to each data string as per the pattern.\n    \"\"\"", "entry_point": "decodeNumbers", "test": "def check(candidate):\n    console.assert(decodeNumbers(\"0000\") === 4)\n    console.assert(decodeNumbers(\"8888\") === 8)\n    console.assert(decodeNumbers(\"1234\") === 1)\n    console.assert(decodeNumbers(\"5678\") === 3)\n    console.assert(decodeNumbers(\"9012\") === 2)\n    console.assert(decodeNumbers(\"1357\") === 0)\n    console.assert(decodeNumbers(\"2468\") === 4)\n    console.assert(decodeNumbers(\"9999\") === 4)\n    console.assert(decodeNumbers(\"1111\") === 0)\n    console.assert(decodeNumbers(\"2222\") === 0)\n    console.assert(decodeNumbers(\"3333\") === 0)\n    console.assert(decodeNumbers(\"4444\") === 4)\n    console.assert(decodeNumbers(\"5555\") === 0)\n    console.assert(decodeNumbers(\"6666\") === 4)\n    console.assert(decodeNumbers(\"7777\") === 0)\n    console.assert(decodeNumbers(\"0001\") === 3)\n    console.assert(decodeNumbers(\"2301\") === 1)\ncheck(decodeNumbers)\n", "given_tests": ["console.assert(decodeNumbers(\"0000\") === 4)"], "solution": "function decodeNumbers(dataStr)\n/**\n Decode a series of numbers to reveal the pattern and understand the actual values each digit represents. The patterns are as follows: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n \n Parameters:\n - dataStr (string): A string representing a series of numbers. The length does not exceed 100 characters.\n \n Returns:\n - number: The result corresponding to each data string as per the pattern.\n*/\n{\n    // Mapping values as per the given pattern\n    const a = [1, 0, 0, 0, 1, 0, 1, 0, 2, 1];\n    let ans = 0;\n    for (let i = 0; i < dataStr.length; i++) {\n        ans += a[dataStr[i] - '0']; // Subtracting '0' to convert char to actual number\n    }\n    return ans;\n}"}
{"task_id": "MBPP_JS/minOperations", "prompt": "def minOperations(...) :\n    \"\"\"\n    Given a 1 by n pixel image, each pixel has a color represented by an integer. You can change all connected pixels of the same color to a chosen color, where two pixels are connected if they are adjacent and have the same color. The goal is to find the minimum number of operations required to make all pixels the same color.\nNote: For each color, there are at most 20 pixels of that color.\n    \"\"\"", "entry_point": "minOperations", "test": "def check(candidate):\n    console.assert(minOperations(5, [1, 2, 3, 2, 1]) === 2)\n    console.assert(minOperations(4, [1, 1, 2, 2]) === 1)\n    console.assert(minOperations(5, [1, 2, 1, 4, 2]) === 3)\n    console.assert(minOperations(5, [5, 5, 5, 5, 5]) === 0)\n    console.assert(minOperations(6, [1, 1, 1, 2, 2, 2]) === 1)\n    console.assert(minOperations(7, [1, 3, 3, 3, 2, 2, 2]) === 2)\n    console.assert(minOperations(8, [4, 4, 4, 4, 3, 3, 3, 3]) === 1)\n    console.assert(minOperations(9, [1, 2, 3, 4, 5, 6, 7, 8, 9]) === 8)\n    console.assert(minOperations(10, [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]) === 5)\n    console.assert(minOperations(3, [3, 3, 3]) === 0)\n    console.assert(minOperations(4, [2, 1, 1, 2]) === 1)\ncheck(minOperations)\n", "given_tests": ["console.assert(minOperations(5, [1, 2, 3, 2, 1]) === 2)"], "solution": "function minOperations(n, pixels)\n/**\n Given a 1 by n pixel image, each pixel has a color represented by an integer. You can change all connected pixels of the same color to a chosen color, where two pixels are connected if they are adjacent and have the same color. The goal is to find the minimum number of operations required to make all pixels the same color.\n Note: For each color, there are at most 20 pixels of that color.\n*/\n{\n    let pre = new Array(n+1).fill(0),\n        u = new Array(n+1).fill(0),\n        f = Array.from({length: n+1}, () => new Array(n+1).fill(Infinity));\n\n    for (let i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    \n    for (let i = 1; i <= n; i++) {\n        f[i][i] = 0;\n    }\n    \n    for (let len = 2; len <= n; len++) {\n        for (let i = 1; i <= n - len + 1; i++) {\n            let j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (let l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = Math.min(f[i][j], f[i][l] + f[l + 1][j]);\n            }\n        }\n    }\n    \n    return f[1][n];\n}"}
{"task_id": "MBPP_JS/findIntegers", "prompt": "def findIntegers(...) :\n    \"\"\"\n    Given integers c and d, where a + b = c and a * b = d, find and return the possible value of a (a <= b). If there are multiple groups, output the group with the smallest a.\n\nParameters:\n  - c (int): The sum of a and b.\n  - d (int): The product of a and b.\n\nReturns:\n  A possible value of a or -1 if valid values do not exist.\n    \"\"\"", "entry_point": "findIntegers", "test": "def check(candidate):\n    console.assert(findIntegers(5, 6) === 2)\n    console.assert(findIntegers(6, 9) === 3)\n    console.assert(findIntegers(7, 12) === 3)\n    console.assert(findIntegers(7, 11) === -1)\n    console.assert(findIntegers(9, 8) === 1)\n    console.assert(findIntegers(10, 25) === 5)\n    console.assert(findIntegers(10000, 8765) === -1)\ncheck(findIntegers)\n", "given_tests": ["console.assert(findIntegers(5, 6) === 2)"], "solution": "function findIntegers(c, d)\n/**\n Given integers c and d, where a + b = c and a * b = d, find and return the possible value of a (a <= b). If there are multiple groups, output the group with the smallest a.\n \n Parameters:\n - c (int): The sum of a and b.\n - d (int): The product of a and b.\n \n Returns:\n A possible value of a or -1 if valid values do not exist.\n*/\n{\n    for (let i = 0; i <= c / 2; i++) {\n        if (i * (c - i) !== d) continue;\n        return i;\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}"}
{"task_id": "MBPP_JS/expectedCuts", "prompt": "def expectedCuts(...) :\n    \"\"\"\n    Given a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left corner at (0,0) and top-right corner at (n,m), you need to calculate the expected number of operations to cut the paper such that the remaining area is less than k. In each operation, a line is randomly chosen that is parallel to the axes, passes through points with integer coordinates, and cuts through (not just touching the edge) the paper. The bottom or right part of the paper along this line is then discarded. The answer should be modulo 10^9+7.\n    \"\"\"", "entry_point": "expectedCuts", "test": "def check(candidate):\n    console.assert(expectedCuts(2, 4, 10) === 0)\n    console.assert(expectedCuts(2, 4, 8) === 1)\n    console.assert(expectedCuts(2, 4, 2) === 833333342)\n    console.assert(expectedCuts(2, 4, 6) === 250000003)\n    console.assert(expectedCuts(3, 3, 4) === 666666673)\n    console.assert(expectedCuts(5, 5, 12) === 666666673)\n    console.assert(expectedCuts(6, 7, 20) === 722222229)\n    console.assert(expectedCuts(10, 10, 50) === 714285721)\n    console.assert(expectedCuts(1, 10, 5) === 945634929)\n    console.assert(expectedCuts(10, 1, 5) === 945634929)\ncheck(expectedCuts)\n", "given_tests": ["console.assert(expectedCuts(2, 4, 10) === 0)"], "solution": "function expectedCuts(n, m, k)\n/**\n Given a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left corner at (0,0) and top-right corner at (n,m), you need to calculate the expected number of operations to cut the paper such that the remaining area is less than k. In each operation, a line is randomly chosen that is parallel to the axes, passes through points with integer coordinates, and cuts through (not just touching the edge) the paper. The bottom or right part of the paper along this line is then discarded. The answer should be modulo 10^9+7.\n*/\n{\n    const MD = 1000000007;\n    const N = 1000000;\n    let vv = new Array(N * 2 + 2).fill(0);\n    let ans = 1;\n\n    vv[1] = 1;\n    for (let i = 2; i <= N * 2; i++)\n        vv[i] = vv[i - MD % i] * (Math.floor(MD / i) + 1) % MD;\n    if (k > n * m) {\n        return 0;\n    }\n\n    for (let i = Math.floor((k + m - 1) / m); i < n; i++) {\n        ans = (ans + vv[i + Math.floor((k + i - 1) / i) - 1]) % MD;\n    }\n    for (let j = Math.floor((k + n - 1) / n); j < m; j++)\n        ans = (ans + vv[Math.floor((k + j - 1) / j) + j - 1]) % MD;\n\n    return ans;\n}"}
{"task_id": "MBPP_JS/maxModeSum", "prompt": "def maxModeSum(...) :\n    \"\"\"\n    Given n positive integers representing the count of each number from 1 to n, find the maximum sum of the mode (most frequent element) for all prefixes of a sequence constructed from these numbers. The mode is the largest number among the most frequent elements in a sequence.\n    \"\"\"", "entry_point": "maxModeSum", "test": "def check(candidate):\n    console.assert(maxModeSum(3, [1, 3, 2]) === 17)\n    console.assert(maxModeSum(4, [4, 1, 2, 3]) === 37)\n    console.assert(maxModeSum(2, [1, 1]) === 4)\n    console.assert(maxModeSum(5, [1, 2, 3, 4, 5]) === 75)\n    console.assert(maxModeSum(1, [100000]) === 100000)\n    console.assert(maxModeSum(5, [5, 3, 2, 4, 1]) === 62)\n    console.assert(maxModeSum(3, [100000, 100000, 100000]) === 900000)\n    console.assert(maxModeSum(3, [2, 2, 5]) === 27)\n    console.assert(maxModeSum(4, [4, 4, 4, 4]) === 64)\n    console.assert(maxModeSum(6, [1, 2, 3, 4, 5, 6]) === 126)\n    console.assert(maxModeSum(3, [3, 1, 2]) === 16)\ncheck(maxModeSum)\n", "given_tests": ["console.assert(maxModeSum(3, [1, 3, 2]) === 17)"], "solution": "function maxModeSum(n, counts)\n/**\n Given n positive integers representing the count of each number from 1 to n, find the maximum sum of the mode (most frequent element) for all prefixes of a sequence constructed from these numbers. The mode is the largest number among the most frequent elements in a sequence.\n*/\n{\n  let ans = 0;\n  let mx = 0;\n  let f = new Array(100000).fill(0); // Initialize the array with zeroes\n\n  for (let i = 0; i <= n; ++i) {\n    f[i] = 0;\n  }\n\n  for (let i = n; i > 0; --i) {\n    while (mx < counts[i - 1]) {\n      mx++;\n      f[mx] = f[mx - 1] + i;\n    }\n    ans += f[counts[i - 1]];\n  }\n  return ans;\n}"}
{"task_id": "MBPP_JS/processRequest", "prompt": "def processRequest(...) :\n    \"\"\"\n    Find the factorial of N and take the modulo 10007 of the result.\n\nParameters:\n- N (number): A non-negative integer representing the input value (N <= 10000).\n\nReturns:\n- number: The result after taking the modulo 10007 of the factorial of N.\n    \"\"\"", "entry_point": "processRequest", "test": "def check(candidate):\n    console.assert(processRequest(0) === 1)\n    console.assert(processRequest(1) === 1)\n    console.assert(processRequest(2) === 2)\n    console.assert(processRequest(3) === 6)\n    console.assert(processRequest(4) === 24)\n    console.assert(processRequest(10) === 6266)\n    console.assert(processRequest(10000) === 6991)\ncheck(processRequest)\n", "given_tests": ["console.assert(processRequest(0) === 1)"], "solution": "function processRequest(n)\n/**\n Find the factorial of N and take the modulo 10007 of the result.\n \n Parameters:\n - N (number): A non-negative integer representing the input value (N <= 10000).\n \n Returns:\n - number: The result after taking the modulo 10007 of the factorial of N.\n*/\n{\n    // An array to store the precomputed factorial modulo results\n    const MOD = 10007;\n    let factorials = new Array(10001);\n    factorials[0] = factorials[1] = 1; // factorial(0) = factorial(1) = 1\n\n    // Precompute the factorials modulo 10007 for integers up to 10000\n    for (let i = 2; i <= 10000; i++) {\n        factorials[i] = (factorials[i - 1] * i) % MOD;\n    }\n\n    return factorials[n];\n}"}
{"task_id": "MBPP_JS/classify_integer", "prompt": "def classify_integer(...) :\n    \"\"\"\n    Classify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until \nthe class is determined.\n\nParameters:\n- x (string): The integer to be classified as a string.\n\nReturns:\nint: The class to which the integer x belongs.\n    \"\"\"", "entry_point": "classify_integer", "test": "def check(candidate):\n    console.assert(classify_integer(\"24\") === 6)\n    console.assert(classify_integer(\"39\") === 3)\n    console.assert(classify_integer(\"123456789\") === 9)\n    console.assert(classify_integer(\"123456789012345678901234567890\") === 9)\n    console.assert(classify_integer(\"12345\") === 6)\n    console.assert(classify_integer(\"999999999\") === 9)\ncheck(classify_integer)\n", "given_tests": ["console.assert(classify_integer(\"24\") === 6)"], "solution": "function classify_integer(x)\n/**\n Classify the integer x based on the following method:\n If x is a single-digit number, x belongs to its own class.\n Otherwise, sum the digits of x, get a new x, and iterate until\n the class is determined.\n \n Parameters:\n - x (string): The integer to be classified as a string.\n \n Returns:\n int: The class to which the integer x belongs.\n*/\n{\n    let n = 0;\n    for (let i = 0; i < x.length; i++) {\n        n += parseInt(x[i], 10);\n    }\n    while (n > 9) {\n        let t = n;\n        let a = 0;\n        while (t) {\n            a += t % 10;\n            t = Math.floor(t / 10);\n        }\n        n = a;\n    }\n    return n;\n}"}
{"task_id": "MBPP_JS/canWinNim", "prompt": "def canWinNim(...) :\n    \"\"\"\n    You are playing a game called Nim. In this game, you start with a pile of n stones, and you and your opponent take turns to remove 1 to 3 stones from the pile. The one who removes the last stone wins the game. Given the number of stones n, determine if you can win the game if both you and your opponent play optimally. Note: You always take the first turn.\n    \"\"\"", "entry_point": "canWinNim", "test": "def check(candidate):\n    console.assert(canWinNim(1) === true)\n    console.assert(canWinNim(2) === true)\n    console.assert(canWinNim(3) === true)\n    console.assert(canWinNim(4) === false)\n    console.assert(canWinNim(5) === true)\n    console.assert(canWinNim(6) === true)\n    console.assert(canWinNim(7) === true)\n    console.assert(canWinNim(8) === false)\n    console.assert(canWinNim(9) === true)\n    console.assert(canWinNim(10) === true)\n    console.assert(canWinNim(11) === true)\n    console.assert(canWinNim(12) === false)\n    console.assert(canWinNim(13) === true)\n    console.assert(canWinNim(14) === true)\n    console.assert(canWinNim(15) === true)\n    console.assert(canWinNim(16) === false)\n    console.assert(canWinNim(17) === true)\n    console.assert(canWinNim(18) === true)\n    console.assert(canWinNim(19) === true)\n    console.assert(canWinNim(20) === false)\ncheck(canWinNim)\n", "given_tests": ["console.assert(canWinNim(1) === true)"], "solution": "function canWinNim(n)\n/**\n You are playing a game called Nim. In this game, you start with a pile of n stones, and you and your opponent take turns to remove 1 to 3 stones from the pile. The one who removes the last stone wins the game. Given the number of stones n, determine if you can win the game if both you and your opponent play optimally. Note: You always take the first turn.\n*/\n{\n    return n % 4 !== 0;\n}"}
{"task_id": "MBPP_JS/processRequest", "prompt": "def processRequest(...) :\n    \"\"\"\n    Find the factorial of N and take the modulo 10007 of the result.\n\nParameters:\n- N (number): A non-negative integer representing the input value (N <= 10000).\n\nReturns:\n- number: The result after taking the modulo 10007 of the factorial of N.\n    \"\"\"", "entry_point": "processRequest", "test": "def check(candidate):\n    console.assert(processRequest(0) === 1)\n    console.assert(processRequest(1) === 1)\n    console.assert(processRequest(2) === 2)\n    console.assert(processRequest(3) === 6)\n    console.assert(processRequest(4) === 24)\n    console.assert(processRequest(10) === 6266)\n    console.assert(processRequest(10000) === 6991)\ncheck(processRequest)\n", "given_tests": ["console.assert(processRequest(0) === 1)"], "solution": "function processRequest(n)\n/**\n Find the factorial of N and take the modulo 10007 of the result.\n \n Parameters:\n - N (number): A non-negative integer representing the input value (N <= 10000).\n \n Returns:\n - number: The result after taking the modulo 10007 of the factorial of N.\n*/\n{\n    // An array to store the precomputed factorial modulo results\n    const MOD = 10007;\n    let factorials = new Array(10001);\n    factorials[0] = factorials[1] = 1; // factorial(0) = factorial(1) = 1\n\n    // Precompute the factorials modulo 10007 for integers up to 10000\n    for (let i = 2; i <= 10000; i++) {\n        factorials[i] = (factorials[i - 1] * i) % MOD;\n    }\n\n    return factorials[n];\n}"}
{"task_id": "MBPP_JS/count_coloring_methods", "prompt": "def count_coloring_methods(...) :\n    \"\"\"\n    Counts the number of different coloring methods for n squares with m colors,\nconsidering the requirement that adjacent squares and the first/last squares\nmust have different colors.\nParameters:\n- n (number): The number of squares.\n- m (number): The number of colors.\nReturns:\n- number: The count of different coloring methods satisfying the conditions,\n           result is modulo 1000003.\n    \"\"\"", "entry_point": "count_coloring_methods", "test": "def check(candidate):\n    console.assert(count_coloring_methods(1, 1) === 1)\n    console.assert(count_coloring_methods(2, 2) === 2)\n    console.assert(count_coloring_methods(3, 3) === 6)\n    console.assert(count_coloring_methods(4, 2) === 2)\n    console.assert(count_coloring_methods(2, 3) === 6)\n    console.assert(count_coloring_methods(1000, 1000) === 67911)\n    console.assert(count_coloring_methods(999, 66) === 501817)\n    console.assert(count_coloring_methods(5, 3) === 30)\ncheck(count_coloring_methods)\n", "given_tests": ["console.assert(count_coloring_methods(1, 1) === 1)"], "solution": "function count_coloring_methods(n, m)\n/**\n Counts the number of different coloring methods for n squares with m colors,\n considering the requirement that adjacent squares and the first/last squares\n must have different colors.\n Parameters:\n - n (number): The number of squares.\n - m (number): The number of colors.\n Returns:\n - number: The count of different coloring methods satisfying the conditions,\n result is modulo 1000003.\n*/\n{\n    const MOD = 1000003;\n    let f = new Array(1111); // Array to store results\n    if (n === 1) return m;\n    if (n === 2) return (m * (m - 1)) % MOD;\n\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (m * (m - 1)) % MOD;\n    // Formula derived from the given gold.c code\n    f[3] = (f[2] * (m - 2)) % MOD;\n\n    for (let i = 4; i <= n; i++) {\n        f[i] = ((f[i - 1] * (m - 2)) % MOD +\n                (f[i - 2] * (m - 1)) % MOD) % MOD;\n    }\n    return f[n];\n}"}
{"task_id": "MBPP_JS/classify_integer", "prompt": "def classify_integer(...) :\n    \"\"\"\n    Classify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until \nthe class is determined.\n\nParameters:\n- x (string): The integer to be classified as a string.\n\nReturns:\nint: The class to which the integer x belongs.\n    \"\"\"", "entry_point": "classify_integer", "test": "def check(candidate):\n    console.assert(classify_integer(\"24\") === 6)\n    console.assert(classify_integer(\"39\") === 3)\n    console.assert(classify_integer(\"123456789\") === 9)\n    console.assert(classify_integer(\"123456789012345678901234567890\") === 9)\n    console.assert(classify_integer(\"12345\") === 6)\n    console.assert(classify_integer(\"999999999\") === 9)\ncheck(classify_integer)\n", "given_tests": ["console.assert(classify_integer(\"24\") === 6)"], "solution": "function classify_integer(x)\n/**\n Classify the integer x based on the following method:\n If x is a single-digit number, x belongs to its own class.\n Otherwise, sum the digits of x, get a new x, and iterate until\n the class is determined.\n \n Parameters:\n - x (string): The integer to be classified as a string.\n \n Returns:\n int: The class to which the integer x belongs.\n*/\n{\n    let n = 0;\n    for (let i = 0; i < x.length; i++) {\n        n += parseInt(x[i], 10);\n    }\n    while (n > 9) {\n        let t = n;\n        let a = 0;\n        while (t) {\n            a += t % 10;\n            t = Math.floor(t / 10);\n        }\n        n = a;\n    }\n    return n;\n}"}
{"task_id": "MBPP_JS/process_integer_and_char", "prompt": "def process_integer_and_char(...) :\n    \"\"\"\n    Reads an integer and a character, then returns them as a formatted string separated by a comma.\nParameters:\n- integer_value (number): The input integer.\n- char_value (string): The input character.\nReturns:\n- string: A string containing the integer and character separated by a comma.\n    \"\"\"", "entry_point": "process_integer_and_char", "test": "def check(candidate):\n    console.assert(process_integer_and_char(234, 'H') === '234,H')\n    console.assert(process_integer_and_char(123, 'A') === '123,A')\n    console.assert(process_integer_and_char(0, 'Z') === '0,Z')\ncheck(process_integer_and_char)\n", "given_tests": ["console.assert(process_integer_and_char(234, 'H') === '234,H')"], "solution": "function process_integer_and_char(integer_value, char_value)\n/**\n Reads an integer and a character, then returns them as a formatted string separated by a comma.\n Parameters:\n - integer_value (number): The input integer.\n - char_value (string): The input character.\n Returns:\n - string: A string containing the integer and character separated by a comma.\n*/\n{\n    // Format the string\n    return `${integer_value},${char_value}`;\n}"}
{"task_id": "MBPP_JS/areIntervalsIntersecting", "prompt": "def areIntervalsIntersecting(...) :\n    \"\"\"\n    Determine if two closed intervals intersect.\n\n@param {number} a - Start of the first closed interval, must satisfy 0 <= a <= b <= 1000.\n@param {number} b - End of the first closed interval, must satisfy 0 <= a <= b <= 1000.\n@param {number} c - Start of the second closed interval, must satisfy 0 <= c <= d <= 1000.\n@param {number} d - End of the second closed interval, must satisfy 0 <= c <= d <= 1000.\n@returns {number} 1 if the intervals intersect, 0 otherwise.\n    \"\"\"", "entry_point": "areIntervalsIntersecting", "test": "def check(candidate):\n    console.assert(areIntervalsIntersecting(1, 1, 1, 2) === 1)\n    console.assert(areIntervalsIntersecting(3, 5, 2, 6) === 1)\n    console.assert(areIntervalsIntersecting(3, 5, 4, 7) === 1)\n    console.assert(areIntervalsIntersecting(3, 5, 6, 7) === 0)\n    console.assert(areIntervalsIntersecting(0, 0, 0, 0) === 1)\n    console.assert(areIntervalsIntersecting(1, 3, 2, 4) === 1)\n    console.assert(areIntervalsIntersecting(1, 3, 4, 6) === 0)\n    console.assert(areIntervalsIntersecting(10, 20, 20, 30) === 1)\n    console.assert(areIntervalsIntersecting(10, 20, 21, 30) === 0)\ncheck(areIntervalsIntersecting)\n", "given_tests": ["console.assert(areIntervalsIntersecting(1, 1, 1, 2) === 1)"], "solution": "function areIntervalsIntersecting(a, b, c, d)\n/**\n Determine if two closed intervals intersect.\n \n @param {number} a - Start of the first closed interval, must satisfy 0 <= a <= b <= 1000.\n @param {number} b - End of the first closed interval, must satisfy 0 <= a <= b <= 1000.\n @param {number} c - Start of the second closed interval, must satisfy 0 <= c <= d <= 1000.\n @param {number} d - End of the second closed interval, must satisfy 0 <= c <= d <= 1000.\n @returns {number} 1 if the intervals intersect, 0 otherwise.\n*/\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}"}
{"task_id": "MBPP_JS/countPermutationsOfBinaryString", "prompt": "def countPermutationsOfBinaryString(...) :\n    \"\"\"\n    Count the number of different permutation schemes for a binary string of length n, where the number of '1's is m and the number of '0's is n - m.\n\nParameters:\n@param {number} n - Length of the binary string.\n@param {number} m - Number of '1's in the binary string.\n\nReturns:\n@returns {number} The total number of different permutation schemes.\n    \"\"\"", "entry_point": "countPermutationsOfBinaryString", "test": "def check(candidate):\n    console.assert(countPermutationsOfBinaryString(2, 0) === 2)\n    console.assert(countPermutationsOfBinaryString(2, 1) === 0)\n    console.assert(countPermutationsOfBinaryString(3, 0) === 0)\n    console.assert(countPermutationsOfBinaryString(3, 1) === 3)\n    console.assert(countPermutationsOfBinaryString(3, 2) === 0)\n    console.assert(countPermutationsOfBinaryString(30, 2) === 145422675)\n    console.assert(countPermutationsOfBinaryString(4, 2) === 4)\n    console.assert(countPermutationsOfBinaryString(5, 5) === 1)\n    console.assert(countPermutationsOfBinaryString(33, 17) === 13884156)\n    console.assert(countPermutationsOfBinaryString(1000, 1000) === 1)\ncheck(countPermutationsOfBinaryString)\n", "given_tests": ["console.assert(countPermutationsOfBinaryString(2, 0) === 2)"], "solution": "function countPermutationsOfBinaryString(n, m)\n/**\n Count the number of different permutation schemes for a binary string of length n, where the number of '1's is m and the number of '0's is n - m.\n \n Parameters:\n @param {number} n - Length of the binary string.\n @param {number} m - Number of '1's in the binary string.\n \n Returns:\n @returns {number} The total number of different permutation schemes.\n*/\n{\n    let factorial = 1;\n    let i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    let numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    let denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    let denominator2 = factorial; // ((n-m)/2)!\n\n    // Check for edge cases\n    if ((n + m) % 2 === 1) {\n        return 0;\n    } else if (n === m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return Math.round(numerator / denominator1 / denominator2);\n    }\n}"}
{"task_id": "MBPP_JS/apocalypseYear", "prompt": "def apocalypseYear(...) :\n    \"\"\"\n    Calculates the year Y_n when the n-th event occurs, considering that each event has a periodicity of a_i years. The countdown for event i+1 starts the year after event i occurs.\nParameters:\n- n (number): The total number of events\n- signs (number[]): An array representing the periodicities of the events\nReturns:\n- number: The year when the n-th event occurs\n    \"\"\"", "entry_point": "apocalypseYear", "test": "def check(candidate):\n    console.assert(apocalypseYear(6, [3, 2, 4, 5, 9, 18]) === 36)\n    console.assert(apocalypseYear(5, [1, 2, 3, 4, 5]) === 5)\n    console.assert(apocalypseYear(5, [1, 1, 1, 1, 1]) === 5)\n    console.assert(apocalypseYear(6, [50, 30, 711, 200, 503, 1006]) === 2012)\n    console.assert(apocalypseYear(2, [1, 2]) === 2)\n    console.assert(apocalypseYear(3, [3, 1, 2]) === 6)\n    console.assert(apocalypseYear(3, [2, 3, 4]) === 4)\n    console.assert(apocalypseYear(4, [1, 2, 3, 4]) === 4)\n    console.assert(apocalypseYear(4, [5, 7, 11, 13]) === 13)\n    console.assert(apocalypseYear(5, [2, 2, 2, 2, 2]) === 10)\n    console.assert(apocalypseYear(3, [6, 10, 15]) === 15)\n    console.assert(apocalypseYear(3, [4, 6, 14]) === 14)\n    console.assert(apocalypseYear(4, [50, 30, 711, 200]) === 800)\n    console.assert(apocalypseYear(6, [1, 1, 1, 1, 1, 1]) === 6)\n    console.assert(apocalypseYear(2, [1000000, 999999]) === 1999998)\ncheck(apocalypseYear)\n", "given_tests": ["console.assert(apocalypseYear(6, [3, 2, 4, 5, 9, 18]) === 36)"], "solution": "function apocalypseYear(n, signs)\n/**\n Calculates the year Y_n when the n-th event occurs, considering that each event has a periodicity of a_i years. The countdown for event i+1 starts the year after event i occurs.\n Parameters:\n - n (number): The total number of events\n - signs (number[]): An array representing the periodicities of the events\n Returns:\n - number: The year when the n-th event occurs\n*/\n{\n    let year = 0;\n    for (let i = 0; i < n; ++i) {\n        let period = signs[i];\n        let nextOccurrence = Math.floor(year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}"}
{"task_id": "MBPP_JS/findLongestConsecutiveOnesLength", "prompt": "def findLongestConsecutiveOnesLength(...) :\n    \"\"\"\n    Find the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n\nParameters:\n@param {number} n - A non-negative integer (0 ≤ n ≤ 2^64 - 1).\n\nReturns:\n@returns {number} The length of the longest consecutive sequence of 1s in the binary representation of the given integer.\n    \"\"\"", "entry_point": "findLongestConsecutiveOnesLength", "test": "def check(candidate):\n    console.assert(findLongestConsecutiveOnesLength(7) === 3)\n    console.assert(findLongestConsecutiveOnesLength(13) === 2)\n    console.assert(findLongestConsecutiveOnesLength(12345) === 3)\n    console.assert(findLongestConsecutiveOnesLength(0b11011101111) === 4)\n    console.assert(findLongestConsecutiveOnesLength(0xFFFFFFFF) === 32)\n    console.assert(findLongestConsecutiveOnesLength(0) === 0)\ncheck(findLongestConsecutiveOnesLength)\n", "given_tests": ["console.assert(findLongestConsecutiveOnesLength(7) === 3)"], "solution": "function findLongestConsecutiveOnesLength(n)\n/**\n Find the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n \n Parameters:\n @param {number} n - A non-negative integer (0 ≤ n ≤ 2^64 - 1).\n \n Returns:\n @returns {number} The length of the longest consecutive sequence of 1s in the binary representation of the given integer.\n*/\n{\n    let max = 0;\n    let ans = 0;\n    while (n) {\n        if (n & 1)\n            ans++;\n        else {\n            if (ans > max)\n                max = ans;\n            ans = 0;\n        }\n        n >>>= 1;\n    }\n    if (ans > max)\n        max = ans;\n    return max;\n}"}
{"task_id": "MBPP_JS/transformLetterCase", "prompt": "def transformLetterCase(...) :\n    \"\"\"\n    Transforms the case of a given letter.\n- letter (char): The input letter to be transformed.\n\nReturns:\n- char: The letter with its case reversed. If the input is lowercase, returns uppercase, and if the input is uppercase, returns lowercase.\n    \"\"\"", "entry_point": "transformLetterCase", "test": "def check(candidate):\n    console.assert(transformLetterCase('b') === 'B')\n    console.assert(transformLetterCase('B') === 'b')\n    console.assert(transformLetterCase('z') === 'Z')\n    console.assert(transformLetterCase('Z') === 'z')\n    console.assert(transformLetterCase('m') === 'M')\n    console.assert(transformLetterCase('M') === 'm')\n    console.assert(transformLetterCase('1') === '1'); // Non-alphabetic, should be unchanged\n    console.assert(transformLetterCase('!') === '!'); // Non-alphabetic, should be unchanged\ncheck(transformLetterCase)\n", "given_tests": ["console.assert(transformLetterCase('b') === 'B')"], "solution": "function transformLetterCase(letter)\n/**\n Transforms the case of a given letter.\n - letter (char): The input letter to be transformed.\n \n Returns:\n - char: The letter with its case reversed. If the input is lowercase, returns uppercase, and if the input is uppercase, returns lowercase.\n*/\n{\n    const charCode = letter.charCodeAt(0);\n    if (charCode >= 'A'.charCodeAt(0) && charCode <= 'Z'.charCodeAt(0)) {\n        // Convert uppercase to lowercase\n        return String.fromCharCode(charCode + ('a'.charCodeAt(0) - 'A'.charCodeAt(0)));\n    } else if (charCode >= 'a'.charCodeAt(0) && charCode <= 'z'.charCodeAt(0)) {\n        // Convert lowercase to uppercase\n        return String.fromCharCode(charCode - ('a'.charCodeAt(0) - 'A'.charCodeAt(0)));\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}"}
{"task_id": "MBPP_JS/checkTwoEqualDigits", "prompt": "def checkTwoEqualDigits(...) :\n    \"\"\"\n    Checks if a string with exactly three characters has two characters that are the same.\n\nParameters:\n- str (string): The three-character string to be checked.\n\nReturns:\n- string: Returns 'Yes' if the input has exactly two equal characters, otherwise 'No'.\n    \"\"\"", "entry_point": "checkTwoEqualDigits", "test": "def check(candidate):\n    console.assert(checkTwoEqualDigits(\"112\") === \"Yes\")\n    console.assert(checkTwoEqualDigits(\"123\") === \"No\")\n    console.assert(checkTwoEqualDigits(\"232\") === \"Yes\")\n    console.assert(checkTwoEqualDigits(\"444\") === \"No\"); // All three characters are equal, not two.\n    console.assert(checkTwoEqualDigits(\"121\") === \"Yes\")\n    console.assert(checkTwoEqualDigits(\"787\") === \"Yes\")\n    console.assert(checkTwoEqualDigits(\"999\") === \"No\"); // All three characters are equal\n    console.assert(checkTwoEqualDigits(\"890\") === \"No\")\n    console.assert(checkTwoEqualDigits(\"556\") === \"Yes\")\n    console.assert(checkTwoEqualDigits(\"353\") === \"Yes\"); // No two characters are equal\ncheck(checkTwoEqualDigits)\n", "given_tests": ["console.assert(checkTwoEqualDigits(\"112\") === \"Yes\")"], "solution": "function checkTwoEqualDigits(str)\n/**\n Checks if a string with exactly three characters has two characters that are the same.\n \n Parameters:\n - str (string): The three-character string to be checked.\n \n Returns:\n - string: Returns 'Yes' if the input has exactly two equal characters, otherwise 'No'.\n*/\n{\n    if ((str[0] === str[1] && str[1] !== str[2]) ||\n        (str[0] === str[2] && str[0] !== str[1]) ||\n        (str[1] === str[2] && str[0] !== str[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}"}
{"task_id": "MBPP_JS/countBalancedSubsequences", "prompt": "def countBalancedSubsequences(...) :\n    \"\"\"\n    Given three integers n, m, and k, find the number of sequences consisting of n '(' and m ')', such that the longest balanced subsequence is of length 2 * k. The result should be calculated modulo 1,000,000,007 (10^9 + 7).\n    \"\"\"", "entry_point": "countBalancedSubsequences", "test": "def check(candidate):\n    console.assert(countBalancedSubsequences(2, 2, 2) === 2)\n    console.assert(countBalancedSubsequences(3, 2, 3) === 0)\n    console.assert(countBalancedSubsequences(3, 2, 1) === 4)\n    console.assert(countBalancedSubsequences(4, 3, 2) === 14)\n    console.assert(countBalancedSubsequences(5, 5, 2) === 35)\n    console.assert(countBalancedSubsequences(6, 1, 1) === 6)\n    console.assert(countBalancedSubsequences(1, 6, 1) === 6)\n    console.assert(countBalancedSubsequences(7, 2, 2) === 27)\n    console.assert(countBalancedSubsequences(8, 3, 3) === 110)\n    console.assert(countBalancedSubsequences(10, 10, 5) === 10659)\n    console.assert(countBalancedSubsequences(20, 20, 10) === 574221648)\n    console.assert(countBalancedSubsequences(2000, 2000, 1000) === 854104531)\n    console.assert(countBalancedSubsequences(2000, 1999, 1000) === 334874485)\n    console.assert(countBalancedSubsequences(2000, 2000, 1999) === 259428024)\ncheck(countBalancedSubsequences)\n", "given_tests": ["console.assert(countBalancedSubsequences(2, 2, 2) === 2)"], "solution": "function countBalancedSubsequences(n, m, k)\n/**\n Given three integers n, m, and k, find the number of sequences consisting of n '(' and m ')', such that the longest balanced subsequence is of length 2 * k. The result should be calculated modulo 1,000,000,007 (10^9 + 7).\n*/\n{\n    const P = 1e9 + 7;\n    const C = Array.from({ length: 4003 }, () => Array(4003).fill(0));\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] === 0) {\n        for (let i = 0; i <= 4002; i++) C[i][0] = 1;\n        for (let i = 1; i <= 4002; i++)\n            for (let j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    \n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}"}
{"task_id": "MBPP_JS/areIntervalsIntersecting", "prompt": "def areIntervalsIntersecting(...) :\n    \"\"\"\n    Determine if two closed intervals intersect.\n\n@param {number} a - Start of the first closed interval, must satisfy 0 <= a <= b <= 1000.\n@param {number} b - End of the first closed interval, must satisfy 0 <= a <= b <= 1000.\n@param {number} c - Start of the second closed interval, must satisfy 0 <= c <= d <= 1000.\n@param {number} d - End of the second closed interval, must satisfy 0 <= c <= d <= 1000.\n@returns {number} 1 if the intervals intersect, 0 otherwise.\n    \"\"\"", "entry_point": "areIntervalsIntersecting", "test": "def check(candidate):\n    console.assert(areIntervalsIntersecting(1, 1, 1, 2) === 1)\n    console.assert(areIntervalsIntersecting(3, 5, 2, 6) === 1)\n    console.assert(areIntervalsIntersecting(3, 5, 4, 7) === 1)\n    console.assert(areIntervalsIntersecting(3, 5, 6, 7) === 0)\n    console.assert(areIntervalsIntersecting(0, 0, 0, 0) === 1)\n    console.assert(areIntervalsIntersecting(1, 3, 2, 4) === 1)\n    console.assert(areIntervalsIntersecting(1, 3, 4, 6) === 0)\n    console.assert(areIntervalsIntersecting(10, 20, 20, 30) === 1)\n    console.assert(areIntervalsIntersecting(10, 20, 21, 30) === 0)\ncheck(areIntervalsIntersecting)\n", "given_tests": ["console.assert(areIntervalsIntersecting(1, 1, 1, 2) === 1)"], "solution": "function areIntervalsIntersecting(a, b, c, d)\n/**\n Determine if two closed intervals intersect.\n \n @param {number} a - Start of the first closed interval, must satisfy 0 <= a <= b <= 1000.\n @param {number} b - End of the first closed interval, must satisfy 0 <= a <= b <= 1000.\n @param {number} c - Start of the second closed interval, must satisfy 0 <= c <= d <= 1000.\n @param {number} d - End of the second closed interval, must satisfy 0 <= c <= d <= 1000.\n @returns {number} 1 if the intervals intersect, 0 otherwise.\n*/\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}"}
{"task_id": "MBPP_JS/extraNumber", "prompt": "def extraNumber(...) :\n    \"\"\"\n    Given three digits a, b, and c, where two of them are equal and the third is different,\nthis function finds and returns the value that occurs exactly once.\n    \"\"\"", "entry_point": "extraNumber", "test": "def check(candidate):\n    console.assert(extraNumber(2, 7, 2) === 7)\n    console.assert(extraNumber(3, 2, 2) === 3)\n    console.assert(extraNumber(5, 5, 1) === 1)\n    console.assert(extraNumber(500000000, 3, 500000000) === 3)\n    console.assert(extraNumber(500000000, 500000000, 3) === 3)\ncheck(extraNumber)\n", "given_tests": ["console.assert(extraNumber(2, 7, 2) === 7)"], "solution": "function extraNumber(a, b, c)\n/**\n Given three digits a, b, and c, where two of them are equal and the third is different,\n this function finds and returns the value that occurs exactly once.\n*/\n{\n    if (a === b) {\n        return c;\n    } else if (a === c) {\n        return b;\n    } else {\n        return a;\n    }\n}"}
{"task_id": "MBPP_JS/sumOfMultiples", "prompt": "def sumOfMultiples(...) :\n    \"\"\"\n    Given an integer n, write a function to compute the sum of all numbers from 1 to n that are multiples of either 3 or 5. If a number is a multiple of both 3 and 5, it should only be counted once.\n    \"\"\"", "entry_point": "sumOfMultiples", "test": "def check(candidate):\n    console.assert(sumOfMultiples(10) === 33)\n    console.assert(sumOfMultiples(15) === 60)\n    console.assert(sumOfMultiples(20) === 98)\n    console.assert(sumOfMultiples(5) === 8)\n    console.assert(sumOfMultiples(3) === 3)\n    console.assert(sumOfMultiples(6) === 14)\n    console.assert(sumOfMultiples(9) === 23)\n    console.assert(sumOfMultiples(12) === 45)\n    console.assert(sumOfMultiples(17) === 60)\n    console.assert(sumOfMultiples(21) === 119)\n    console.assert(sumOfMultiples(25) === 168)\ncheck(sumOfMultiples)\n", "given_tests": ["console.assert(sumOfMultiples(10) === 33)"], "solution": "function sumOfMultiples(n)\n/**\n Given an integer n, write a function to compute the sum of all numbers from 1 to n that are multiples of either 3 or 5. If a number is a multiple of both 3 and 5, it should only be counted once.\n*/\n{\n    let sum = 0;\n    for (let i = 1; i <= n; ++i) {\n        if (i % 3 === 0 || i % 5 === 0) {\n            sum += i;\n        }\n    }\n    return sum;\n}"}
{"task_id": "MBPP_JS/countHandshakes", "prompt": "def countHandshakes(...) :\n    \"\"\"\n    Given a sequence of student IDs entering a classroom, where the IDs range from 0 to N-1,\ncalculate the total number of handshakes that occur. Each student will shake hands with\nevery student already in the classroom who has a smaller ID number. The sequence represents\nthe order in which students enter the classroom.\n    \"\"\"", "entry_point": "countHandshakes", "test": "def check(candidate):\n    console.assert(countHandshakes(4, [2, 1, 3, 0]) === 2)\n    console.assert(countHandshakes(6, [0, 1, 2, 3, 4, 5]) === 15)\n    console.assert(countHandshakes(3, [1, 2, 0]) === 1)\n    console.assert(countHandshakes(4, [3, 2, 1, 0]) === 0)\n    console.assert(countHandshakes(4, [0, 1, 2, 3]) === 6)\n    console.assert(countHandshakes(6, [5, 4, 3, 2, 1, 0]) === 0)\n    console.assert(countHandshakes(4, [0, 2, 1, 3]) === 5)\n    console.assert(countHandshakes(5, [3, 1, 4, 2, 0]) === 3)\n    console.assert(countHandshakes(4, [1, 0, 3, 2]) === 4)\n    console.assert(countHandshakes(3, [2, 0, 1]) === 1)\n    console.assert(countHandshakes(5, [1, 3, 0, 2, 4]) === 7)\n    console.assert(countHandshakes(5, [4, 3, 2, 1, 0]) === 0)\ncheck(countHandshakes)\n", "given_tests": ["console.assert(countHandshakes(4, [2, 1, 3, 0]) === 2)"], "solution": "function countHandshakes(n, order)\n/**\n Given a sequence of student IDs entering a classroom, where the IDs range from 0 to N-1,\n calculate the total number of handshakes that occur. Each student will shake hands with\n every student already in the classroom who has a smaller ID number. The sequence represents\n the order in which students enter the classroom.\n*/\n{\n    let ans = 0;\n    const tr = new Array(n + 1).fill(0); // Increase the size to accommodate 1-indexed values.\n    for (let i = 0; i < n; ++i) {\n        let x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (let j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (let j = x; j <= n; j += j & (-j)) {\n            tr[j]++;\n        }\n    }\n    return ans;\n}"}
{"task_id": "MBPP_JS/display_ascii_info", "prompt": "def display_ascii_info(...) :\n    \"\"\"\n    Display the ASCII information for a given character.\n\nParameters:\n@param {char} character - The input character for which ASCII information is to be displayed.\n\nReturns:\n@returns {number} - The corresponding ASCII code.\n\nExamples:\ndisplay_ascii_info('A');\n// => 65\n    \"\"\"", "entry_point": "display_ascii_info", "test": "def check(candidate):\n    console.assert(display_ascii_info('A') === 65)\n    console.assert(display_ascii_info('B') === 66)\n    console.assert(display_ascii_info('0') === 48)\n    console.assert(display_ascii_info(' ') === 32)\ncheck(display_ascii_info)\n", "given_tests": ["console.assert(display_ascii_info('A') === 65)"], "solution": "function display_ascii_info(character)\n/**\n Display the ASCII information for a given character.\n \n Parameters:\n @param {char} character - The input character for which ASCII information is to be displayed.\n \n Returns:\n @returns {number} - The corresponding ASCII code.\n \n Examples:\n display_ascii_info('A');\n // => 65\n*/\n{\n    return character.charCodeAt(0);\n}"}
{"task_id": "MBPP_JS/maxModeSum", "prompt": "def maxModeSum(...) :\n    \"\"\"\n    Given n positive integers representing the count of each number from 1 to n, find the maximum sum of the mode (most frequent element) for all prefixes of a sequence constructed from these numbers. The mode is the largest number among the most frequent elements in a sequence.\n    \"\"\"", "entry_point": "maxModeSum", "test": "def check(candidate):\n    console.assert(maxModeSum(3, [1, 3, 2]) === 17)\n    console.assert(maxModeSum(4, [4, 1, 2, 3]) === 37)\n    console.assert(maxModeSum(2, [1, 1]) === 4)\n    console.assert(maxModeSum(5, [1, 2, 3, 4, 5]) === 75)\n    console.assert(maxModeSum(1, [100000]) === 100000)\n    console.assert(maxModeSum(5, [5, 3, 2, 4, 1]) === 62)\n    console.assert(maxModeSum(3, [100000, 100000, 100000]) === 900000)\n    console.assert(maxModeSum(3, [2, 2, 5]) === 27)\n    console.assert(maxModeSum(4, [4, 4, 4, 4]) === 64)\n    console.assert(maxModeSum(6, [1, 2, 3, 4, 5, 6]) === 126)\n    console.assert(maxModeSum(3, [3, 1, 2]) === 16)\ncheck(maxModeSum)\n", "given_tests": ["console.assert(maxModeSum(3, [1, 3, 2]) === 17)"], "solution": "function maxModeSum(n, counts)\n/**\n Given n positive integers representing the count of each number from 1 to n, find the maximum sum of the mode (most frequent element) for all prefixes of a sequence constructed from these numbers. The mode is the largest number among the most frequent elements in a sequence.\n*/\n{\n  let ans = 0;\n  let mx = 0;\n  let f = new Array(100000).fill(0); // Initialize the array with zeroes\n\n  for (let i = 0; i <= n; ++i) {\n    f[i] = 0;\n  }\n\n  for (let i = n; i > 0; --i) {\n    while (mx < counts[i - 1]) {\n      mx++;\n      f[mx] = f[mx - 1] + i;\n    }\n    ans += f[counts[i - 1]];\n  }\n  return ans;\n}"}
{"task_id": "MBPP_JS/shiftCharacters", "prompt": "def shiftCharacters(...) :\n    \"\"\"\n    Shifts all characters by 5 positions in alphabetical order.\nOnly letters are replaced, and all letters are in uppercase.\n\nParameters:\n- text (string): The input text to be processed.\n\nReturns:\n- string: The transformed text with characters shifted by 5 positions.\n    \"\"\"", "entry_point": "shiftCharacters", "test": "def check(candidate):\n    console.assert(shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") === \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\")\n    console.assert(shiftCharacters(\"N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ\") === \"I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME\")\n    console.assert(shiftCharacters(\"IFSLJW PSTBX KZQQ BJQQ YMFY HFJXFW NX RTWJ IFSLJWTZX YMFS MJ\") === \"DANGER KNOWS FULL WELL THAT CAESAR IS MORE DANGEROUS THAN HE\")\ncheck(shiftCharacters)\n", "given_tests": ["console.assert(shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") === \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\")"], "solution": "function shiftCharacters(text)\n/**\n Shifts all characters by 5 positions in alphabetical order.\n Only letters are replaced, and all letters are in uppercase.\n \n Parameters:\n - text (string): The input text to be processed.\n \n Returns:\n - string: The transformed text with characters shifted by 5 positions.\n*/\n{\n    let shiftedText = '';\n    for (let i = 0; i < text.length; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            shiftedText += String.fromCharCode(text.charCodeAt(i) + 21); // 'V' - 'A' = 21\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            shiftedText += String.fromCharCode(text.charCodeAt(i) - 5); // 'A' - 'F' = -5\n        } else {\n            shiftedText += text[i];\n        }\n    }\n    return shiftedText;\n}"}
{"task_id": "MBPP_JS/minRoundsToSameChar", "prompt": "def minRoundsToSameChar(...) :\n    \"\"\"\n    Given a string consisting of lowercase English letters, you can change one character to another in each round. This function calculates the minimum number of rounds needed to make the string composed of the same character.\n@param {string} s - The input string.\n@returns {number} The minimum number of rounds to make all characters in the string the same.\n    \"\"\"", "entry_point": "minRoundsToSameChar", "test": "def check(candidate):\n    console.assert(minRoundsToSameChar(\"aab\") === 1)\n    console.assert(minRoundsToSameChar(\"abc\") === 2)\n    console.assert(minRoundsToSameChar(\"aaa\") === 0)\n    console.assert(minRoundsToSameChar(\"abab\") === 1)\n    console.assert(minRoundsToSameChar(\"zzzzz\") === 0)\ncheck(minRoundsToSameChar)\n", "given_tests": ["console.assert(minRoundsToSameChar(\"aab\") === 1)"], "solution": "function minRoundsToSameChar(s)\n/**\n Given a string consisting of lowercase English letters, you can change one character to another in each round. This function calculates the minimum number of rounds needed to make the string composed of the same character.\n @param {string} s - The input string.\n @returns {number} The minimum number of rounds to make all characters in the string the same.\n*/\n{\n    const charCount = new Array(26).fill(0); // Assuming only lowercase letters\n    for (const char of s) {\n        charCount[char.charCodeAt(0) - 'a'.charCodeAt(0)]++;\n    }\n    let maxCount = 0;\n    for (const count of charCount) {\n        if (count !== 0) {\n            maxCount++;\n        }\n    }\n\n    return maxCount - 1;\n}"}
{"task_id": "MBPP_JS/decodeNumbers", "prompt": "def decodeNumbers(...) :\n    \"\"\"\n    Decode a series of numbers to reveal the pattern and understand the actual values each digit represents. The patterns are as follows: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nParameters:\n- dataStr (string): A string representing a series of numbers. The length does not exceed 100 characters.\n\nReturns:\n- number: The result corresponding to each data string as per the pattern.\n    \"\"\"", "entry_point": "decodeNumbers", "test": "def check(candidate):\n    console.assert(decodeNumbers(\"0000\") === 4)\n    console.assert(decodeNumbers(\"8888\") === 8)\n    console.assert(decodeNumbers(\"1234\") === 1)\n    console.assert(decodeNumbers(\"5678\") === 3)\n    console.assert(decodeNumbers(\"9012\") === 2)\n    console.assert(decodeNumbers(\"1357\") === 0)\n    console.assert(decodeNumbers(\"2468\") === 4)\n    console.assert(decodeNumbers(\"9999\") === 4)\n    console.assert(decodeNumbers(\"1111\") === 0)\n    console.assert(decodeNumbers(\"2222\") === 0)\n    console.assert(decodeNumbers(\"3333\") === 0)\n    console.assert(decodeNumbers(\"4444\") === 4)\n    console.assert(decodeNumbers(\"5555\") === 0)\n    console.assert(decodeNumbers(\"6666\") === 4)\n    console.assert(decodeNumbers(\"7777\") === 0)\n    console.assert(decodeNumbers(\"0001\") === 3)\n    console.assert(decodeNumbers(\"2301\") === 1)\ncheck(decodeNumbers)\n", "given_tests": ["console.assert(decodeNumbers(\"0000\") === 4)"], "solution": "function decodeNumbers(dataStr)\n/**\n Decode a series of numbers to reveal the pattern and understand the actual values each digit represents. The patterns are as follows: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n \n Parameters:\n - dataStr (string): A string representing a series of numbers. The length does not exceed 100 characters.\n \n Returns:\n - number: The result corresponding to each data string as per the pattern.\n*/\n{\n    // Mapping values as per the given pattern\n    const a = [1, 0, 0, 0, 1, 0, 1, 0, 2, 1];\n    let ans = 0;\n    for (let i = 0; i < dataStr.length; i++) {\n        ans += a[dataStr[i] - '0']; // Subtracting '0' to convert char to actual number\n    }\n    return ans;\n}"}
{"task_id": "MBPP_JS/checkTwoEqualDigits", "prompt": "def checkTwoEqualDigits(...) :\n    \"\"\"\n    Checks if a string with exactly three characters has two characters that are the same.\n\nParameters:\n- str (string): The three-character string to be checked.\n\nReturns:\n- string: Returns 'Yes' if the input has exactly two equal characters, otherwise 'No'.\n    \"\"\"", "entry_point": "checkTwoEqualDigits", "test": "def check(candidate):\n    console.assert(checkTwoEqualDigits(\"112\") === \"Yes\")\n    console.assert(checkTwoEqualDigits(\"123\") === \"No\")\n    console.assert(checkTwoEqualDigits(\"232\") === \"Yes\")\n    console.assert(checkTwoEqualDigits(\"444\") === \"No\"); // All three characters are equal, not two.\n    console.assert(checkTwoEqualDigits(\"121\") === \"Yes\")\n    console.assert(checkTwoEqualDigits(\"787\") === \"Yes\")\n    console.assert(checkTwoEqualDigits(\"999\") === \"No\"); // All three characters are equal\n    console.assert(checkTwoEqualDigits(\"890\") === \"No\")\n    console.assert(checkTwoEqualDigits(\"556\") === \"Yes\")\n    console.assert(checkTwoEqualDigits(\"353\") === \"Yes\"); // No two characters are equal\ncheck(checkTwoEqualDigits)\n", "given_tests": ["console.assert(checkTwoEqualDigits(\"112\") === \"Yes\")"], "solution": "function checkTwoEqualDigits(str)\n/**\n Checks if a string with exactly three characters has two characters that are the same.\n \n Parameters:\n - str (string): The three-character string to be checked.\n \n Returns:\n - string: Returns 'Yes' if the input has exactly two equal characters, otherwise 'No'.\n*/\n{\n    if ((str[0] === str[1] && str[1] !== str[2]) ||\n        (str[0] === str[2] && str[0] !== str[1]) ||\n        (str[1] === str[2] && str[0] !== str[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}"}
{"task_id": "MBPP_JS/createId", "prompt": "def createId(...) :\n    \"\"\"\n    Creates an ID by combining two strings in a specific manner.\nParameters:\n- word1 (string): The first string to be used in the ID.\n- word2 (string): The second string to be used in the ID.\nReturns:\nstring: A divine ID formed by reversing every other character of the second string and combining it with the first string.\n    \"\"\"", "entry_point": "createId", "test": "def check(candidate):\n    console.assert(createId(\"fish\", \"cat\") === \"ftiasch\")\n    console.assert(createId(\"icpc\", \"acm\") === \"imccpac\")\n    console.assert(createId(\"oo\", \"w\") === \"owo\")\n    console.assert(createId(\"hello\", \"world\") === \"hdellrloow\")\n    console.assert(createId(\"abc\", \"def\") === \"afbecd\")\n    console.assert(createId(\"buaanb\", \"nbbuaa\") === \"bauaauabnbbn\")\n    console.assert(createId(\"xtuisgood\", \"ilovextu\") === \"xuttuxiesvgooloid\")\ncheck(createId)\n", "given_tests": ["console.assert(createId(\"fish\", \"cat\") === \"ftiasch\")"], "solution": "function createId(word1, word2)\n/**\n Creates an ID by combining two strings in a specific manner.\n Parameters:\n - word1 (string): The first string to be used in the ID.\n - word2 (string): The second string to be used in the ID.\n Returns:\n string: A divine ID formed by reversing every other character of the second string and combining it with the first string.\n*/\n{\n    let id = '';\n    for (let i = 0, k = 0, j = word2.length - 1; i < word1.length + word2.length; i++) {\n        if (i % 2 === 0) {\n            id += word1.charAt(k++); // Take character from word1\n        } else {\n            id += word2.charAt(j--); // Take character from word2 in reverse\n        }\n    }\n    return id;\n}"}
{"task_id": "MBPP_JS/transformLetterCase", "prompt": "def transformLetterCase(...) :\n    \"\"\"\n    Transforms the case of a given letter.\n- letter (char): The input letter to be transformed.\n\nReturns:\n- char: The letter with its case reversed. If the input is lowercase, returns uppercase, and if the input is uppercase, returns lowercase.\n    \"\"\"", "entry_point": "transformLetterCase", "test": "def check(candidate):\n    console.assert(transformLetterCase('b') === 'B')\n    console.assert(transformLetterCase('B') === 'b')\n    console.assert(transformLetterCase('z') === 'Z')\n    console.assert(transformLetterCase('Z') === 'z')\n    console.assert(transformLetterCase('m') === 'M')\n    console.assert(transformLetterCase('M') === 'm')\n    console.assert(transformLetterCase('1') === '1'); // Non-alphabetic, should be unchanged\n    console.assert(transformLetterCase('!') === '!'); // Non-alphabetic, should be unchanged\ncheck(transformLetterCase)\n", "given_tests": ["console.assert(transformLetterCase('b') === 'B')"], "solution": "function transformLetterCase(letter)\n/**\n Transforms the case of a given letter.\n - letter (char): The input letter to be transformed.\n \n Returns:\n - char: The letter with its case reversed. If the input is lowercase, returns uppercase, and if the input is uppercase, returns lowercase.\n*/\n{\n    const charCode = letter.charCodeAt(0);\n    if (charCode >= 'A'.charCodeAt(0) && charCode <= 'Z'.charCodeAt(0)) {\n        // Convert uppercase to lowercase\n        return String.fromCharCode(charCode + ('a'.charCodeAt(0) - 'A'.charCodeAt(0)));\n    } else if (charCode >= 'a'.charCodeAt(0) && charCode <= 'z'.charCodeAt(0)) {\n        // Convert lowercase to uppercase\n        return String.fromCharCode(charCode - ('a'.charCodeAt(0) - 'A'.charCodeAt(0)));\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}"}
{"task_id": "MBPP_JS/countPermutationsOfBinaryString", "prompt": "def countPermutationsOfBinaryString(...) :\n    \"\"\"\n    Count the number of different permutation schemes for a binary string of length n, where the number of '1's is m and the number of '0's is n - m.\n\nParameters:\n@param {number} n - Length of the binary string.\n@param {number} m - Number of '1's in the binary string.\n\nReturns:\n@returns {number} The total number of different permutation schemes.\n    \"\"\"", "entry_point": "countPermutationsOfBinaryString", "test": "def check(candidate):\n    console.assert(countPermutationsOfBinaryString(2, 0) === 2)\n    console.assert(countPermutationsOfBinaryString(2, 1) === 0)\n    console.assert(countPermutationsOfBinaryString(3, 0) === 0)\n    console.assert(countPermutationsOfBinaryString(3, 1) === 3)\n    console.assert(countPermutationsOfBinaryString(3, 2) === 0)\n    console.assert(countPermutationsOfBinaryString(30, 2) === 145422675)\n    console.assert(countPermutationsOfBinaryString(4, 2) === 4)\n    console.assert(countPermutationsOfBinaryString(5, 5) === 1)\n    console.assert(countPermutationsOfBinaryString(33, 17) === 13884156)\n    console.assert(countPermutationsOfBinaryString(1000, 1000) === 1)\ncheck(countPermutationsOfBinaryString)\n", "given_tests": ["console.assert(countPermutationsOfBinaryString(2, 0) === 2)"], "solution": "function countPermutationsOfBinaryString(n, m)\n/**\n Count the number of different permutation schemes for a binary string of length n, where the number of '1's is m and the number of '0's is n - m.\n \n Parameters:\n @param {number} n - Length of the binary string.\n @param {number} m - Number of '1's in the binary string.\n \n Returns:\n @returns {number} The total number of different permutation schemes.\n*/\n{\n    let factorial = 1;\n    let i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    let numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    let denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    let denominator2 = factorial; // ((n-m)/2)!\n\n    // Check for edge cases\n    if ((n + m) % 2 === 1) {\n        return 0;\n    } else if (n === m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return Math.round(numerator / denominator1 / denominator2);\n    }\n}"}
{"task_id": "MBPP_JS/countTriplets", "prompt": "def countTriplets(...) :\n    \"\"\"\n    Determines the number of ways to choose a triplet (a, b, c) from an array of distinct integers representing heights such that the greatest common divisor (GCD) of the maximum and minimum values of the triplet is 1.\n    \"\"\"", "entry_point": "countTriplets", "test": "def check(candidate):\n    console.assert(countTriplets([1, 5, 7]) === 1)\n    console.assert(countTriplets([1, 6, 2, 3]) === 3)\n    console.assert(countTriplets([16, 4, 8, 2]) === 0)\n    console.assert(countTriplets([10, 1, 6, 7, 9, 8, 4, 3, 5, 2]) === 77)\n    console.assert(countTriplets([4, 5, 9, 11, 14]) === 7)\n    console.assert(countTriplets([15, 10, 6, 9, 7, 3, 12, 8, 11, 1, 2]) === 104)\n    console.assert(countTriplets([3, 7, 11, 13]) === 4)\n    console.assert(countTriplets([5, 12, 13, 17, 19]) === 10)\n    console.assert(countTriplets([2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]) === 87)\n    console.assert(countTriplets([1, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]) === 122)\ncheck(countTriplets)\n", "given_tests": ["console.assert(countTriplets([1, 5, 7]) === 1)"], "solution": "function countTriplets(heights)\n/**\n Determines the number of ways to choose a triplet (a, b, c) from an array of distinct integers representing heights such that the greatest common divisor (GCD) of the maximum and minimum values of the triplet is 1.\n*/\n{\n    let count = 0;\n    const n = heights.length;\n    for (let i = 0; i < n; ++i) {\n        for (let j = i + 1; j < n; ++j) {\n            for (let k = j + 1; k < n; ++k) {\n                const minVal = Math.min(heights[i], heights[j], heights[k]);\n                const maxVal = Math.max(heights[i], heights[j], heights[k]);\n                if (gcd(minVal, maxVal) === 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\n// Helper function to find the greatest common divisor\nfunction gcd(a, b) {\n    while (b !== 0) {\n        let t = b;\n        b = a % b;\n        a = t;\n    }\n    return a;\n}"}
{"task_id": "MBPP_JS/calculateEvenSum", "prompt": "def calculateEvenSum(...) :\n    \"\"\"\n    Calculate the sum of even numbers in a given list.\nParameters:\n- numbers (Array): An array of integers.\n- size (Number): The size of the array.\nReturns:\n  Number: The sum of even numbers in the input array.\nExample usage:\n  calculateEvenSum([1, 4, 3, 2, 5], 5)  // returns 6\n    \"\"\"", "entry_point": "calculateEvenSum", "test": "def check(candidate):\n    console.assert(calculateEvenSum([1, 4, 3, 2, 5], 5) === 6)\n    console.assert(calculateEvenSum([2, 2, 0, 0], 4) === 4)\n    console.assert(calculateEvenSum([7, 11, 19], 3) === 0); // Should return 0 because there are no even numbers\n    console.assert(calculateEvenSum([12, 14, 16, 18, 20], 5) === (12 + 14 + 16 + 18 + 20))\ncheck(calculateEvenSum)\n", "given_tests": ["console.assert(calculateEvenSum([1, 4, 3, 2, 5], 5) === 6)"], "solution": "function calculateEvenSum(numbers, size)\n/**\n Calculate the sum of even numbers in a given list.\n Parameters:\n - numbers (Array): An array of integers.\n - size (Number): The size of the array.\n Returns:\n Number: The sum of even numbers in the input array.\n Example usage:\n calculateEvenSum([1, 4, 3, 2, 5], 5)  // returns 6\n*/\n{\n    let ans = 0;\n    for (let i = 0; i < size; i++) {\n        if (numbers[i] % 2 === 0) { // Only sum the even numbers\n            ans += numbers[i];\n        }\n    }\n    return ans;\n}"}
{"task_id": "MBPP_JS/gameWinner", "prompt": "def gameWinner(...) :\n    \"\"\"\n    Given a sequence of N piles of stones numbered from 1 to N, with each pile containing a positive number of stones,\n determine the winner of a game played by Charlie and Dan. Charlie goes first, and they take turns moving a\n positive number of stones from the leftmost non-empty pile to the adjacent right pile. The player who can\n only move stones in the last pile loses. Assuming both players use the best possible strategy, find out\n who will win the game.\n    \"\"\"", "entry_point": "gameWinner", "test": "def check(candidate):\n    console.assert(gameWinner([1, 2, 2]) === \"Dan\")\n    console.assert(gameWinner([5, 5, 5, 5, 5]) === \"Charlie\")\n    console.assert(gameWinner([2, 1, 2]) === \"Charlie\")\n    console.assert(gameWinner([3, 3, 3, 3]) === \"Charlie\")\n    console.assert(gameWinner([1, 1]) === \"Charlie\")\n    console.assert(gameWinner([2, 1]) === \"Charlie\")\n    console.assert(gameWinner([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) === \"Dan\")\n    console.assert(gameWinner([2, 2, 2, 2, 2, 2, 2, 2, 2, 1]) === \"Charlie\")\n    console.assert(gameWinner([10, 10, 10, 10, 10, 10, 10, 10, 10, 10]) === \"Charlie\")\n    console.assert(gameWinner([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) === \"Dan\")\ncheck(gameWinner)\n", "given_tests": ["console.assert(gameWinner([1, 2, 2]) === \"Dan\")"], "solution": "function gameWinner(piles)\n/**\n Given a sequence of N piles of stones numbered from 1 to N, with each pile containing a positive number of stones,\n determine the winner of a game played by Charlie and Dan. Charlie goes first, and they take turns moving a\n positive number of stones from the leftmost non-empty pile to the adjacent right pile. The player who can\n only move stones in the last pile loses. Assuming both players use the best possible strategy, find out\n who will win the game.\n*/\n{\n    const n = piles.length;\n    const firstPileStones = piles[0];\n    \n    if (n === 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones === 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}"}
{"task_id": "MBPP_JS/apocalypseYear", "prompt": "def apocalypseYear(...) :\n    \"\"\"\n    Calculates the year Y_n when the n-th event occurs, considering that each event has a periodicity of a_i years. The countdown for event i+1 starts the year after event i occurs.\nParameters:\n- n (number): The total number of events\n- signs (number[]): An array representing the periodicities of the events\nReturns:\n- number: The year when the n-th event occurs\n    \"\"\"", "entry_point": "apocalypseYear", "test": "def check(candidate):\n    console.assert(apocalypseYear(6, [3, 2, 4, 5, 9, 18]) === 36)\n    console.assert(apocalypseYear(5, [1, 2, 3, 4, 5]) === 5)\n    console.assert(apocalypseYear(5, [1, 1, 1, 1, 1]) === 5)\n    console.assert(apocalypseYear(6, [50, 30, 711, 200, 503, 1006]) === 2012)\n    console.assert(apocalypseYear(2, [1, 2]) === 2)\n    console.assert(apocalypseYear(3, [3, 1, 2]) === 6)\n    console.assert(apocalypseYear(3, [2, 3, 4]) === 4)\n    console.assert(apocalypseYear(4, [1, 2, 3, 4]) === 4)\n    console.assert(apocalypseYear(4, [5, 7, 11, 13]) === 13)\n    console.assert(apocalypseYear(5, [2, 2, 2, 2, 2]) === 10)\n    console.assert(apocalypseYear(3, [6, 10, 15]) === 15)\n    console.assert(apocalypseYear(3, [4, 6, 14]) === 14)\n    console.assert(apocalypseYear(4, [50, 30, 711, 200]) === 800)\n    console.assert(apocalypseYear(6, [1, 1, 1, 1, 1, 1]) === 6)\n    console.assert(apocalypseYear(2, [1000000, 999999]) === 1999998)\ncheck(apocalypseYear)\n", "given_tests": ["console.assert(apocalypseYear(6, [3, 2, 4, 5, 9, 18]) === 36)"], "solution": "function apocalypseYear(n, signs)\n/**\n Calculates the year Y_n when the n-th event occurs, considering that each event has a periodicity of a_i years. The countdown for event i+1 starts the year after event i occurs.\n Parameters:\n - n (number): The total number of events\n - signs (number[]): An array representing the periodicities of the events\n Returns:\n - number: The year when the n-th event occurs\n*/\n{\n    let year = 0;\n    for (let i = 0; i < n; ++i) {\n        let period = signs[i];\n        let nextOccurrence = Math.floor(year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}"}
{"task_id": "MBPP_JS/gameWinner", "prompt": "def gameWinner(...) :\n    \"\"\"\n    Given a sequence of N piles of stones numbered from 1 to N, with each pile containing a positive number of stones,\n determine the winner of a game played by Charlie and Dan. Charlie goes first, and they take turns moving a\n positive number of stones from the leftmost non-empty pile to the adjacent right pile. The player who can\n only move stones in the last pile loses. Assuming both players use the best possible strategy, find out\n who will win the game.\n    \"\"\"", "entry_point": "gameWinner", "test": "def check(candidate):\n    console.assert(gameWinner([1, 2, 2]) === \"Dan\")\n    console.assert(gameWinner([5, 5, 5, 5, 5]) === \"Charlie\")\n    console.assert(gameWinner([2, 1, 2]) === \"Charlie\")\n    console.assert(gameWinner([3, 3, 3, 3]) === \"Charlie\")\n    console.assert(gameWinner([1, 1]) === \"Charlie\")\n    console.assert(gameWinner([2, 1]) === \"Charlie\")\n    console.assert(gameWinner([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) === \"Dan\")\n    console.assert(gameWinner([2, 2, 2, 2, 2, 2, 2, 2, 2, 1]) === \"Charlie\")\n    console.assert(gameWinner([10, 10, 10, 10, 10, 10, 10, 10, 10, 10]) === \"Charlie\")\n    console.assert(gameWinner([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) === \"Dan\")\ncheck(gameWinner)\n", "given_tests": ["console.assert(gameWinner([1, 2, 2]) === \"Dan\")"], "solution": "function gameWinner(piles)\n/**\n Given a sequence of N piles of stones numbered from 1 to N, with each pile containing a positive number of stones,\n determine the winner of a game played by Charlie and Dan. Charlie goes first, and they take turns moving a\n positive number of stones from the leftmost non-empty pile to the adjacent right pile. The player who can\n only move stones in the last pile loses. Assuming both players use the best possible strategy, find out\n who will win the game.\n*/\n{\n    const n = piles.length;\n    const firstPileStones = piles[0];\n    \n    if (n === 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones === 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}"}
{"task_id": "MBPP_JS/sumOfXorSubarrays", "prompt": "def sumOfXorSubarrays(...) :\n    \"\"\"\n    Given an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\nA subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= the length of the array.\nThe XOR sum of a subarray is the result of XORing all elements from L to R.\nThe final result is the sum of the XOR sums for all possible subarrays.\n    \"\"\"", "entry_point": "sumOfXorSubarrays", "test": "def check(candidate):\n    console.assert(sumOfXorSubarrays([1, 2, 3, 4, 5]) === 39)\n    console.assert(sumOfXorSubarrays([1, 1, 1]) === 4)\n    console.assert(sumOfXorSubarrays([2, 3, 1]) === 9)\n    console.assert(sumOfXorSubarrays([4, 5, 7, 9]) === 74)\n    console.assert(sumOfXorSubarrays([0, 0, 0, 0]) === 0)\n    console.assert(sumOfXorSubarrays([8, 8, 8, 8, 8]) === 72)\n    console.assert(sumOfXorSubarrays([3, 6, 9, 12, 15]) === 125)\n    console.assert(sumOfXorSubarrays([10, 20, 30, 40, 50]) === 390)\n    console.assert(sumOfXorSubarrays([16, 16, 16, 16, 16, 16]) === 192)\n    console.assert(sumOfXorSubarrays([1, 3, 5, 7, 9, 11, 13]) === 192)\n    console.assert(sumOfXorSubarrays([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) === 218)\ncheck(sumOfXorSubarrays)\n", "given_tests": ["console.assert(sumOfXorSubarrays([1, 2, 3, 4, 5]) === 39)"], "solution": "function sumOfXorSubarrays(A)\n/**\n Given an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\n A subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= the length of the array.\n The XOR sum of a subarray is the result of XORing all elements from L to R.\n The final result is the sum of the XOR sums for all possible subarrays.\n*/\n{\n    const n = A.length;\n    let q = new Array(n + 1).fill(0);\n    let w = Array.from({ length: 21 }, () => [0, 0]);\n    let ans = 0;\n\n    for (let i = 1; i <= n; i++) {\n        q[i] = q[i - 1] ^ A[i - 1];\n    }\n\n    for (let i = 0; i <= n; i++) {\n        for (let j = 20; j >= 0; j--) {\n            w[j][(q[i] >> j) & 1]++;\n        }\n    }\n\n    for (let i = 0; i <= 20; i++) {\n        ans += w[i][0] * w[i][1] * (1 << i);\n    }\n\n    return ans;\n}"}
{"task_id": "MBPP_JS/evaluate_integer_grade", "prompt": "def evaluate_integer_grade(...) :\n    \"\"\"\n    Evaluate the grade for an input integer.\n\nParameters:\n- score (int): The integer score to be evaluated.\n\nReturns:\n    char: The grade corresponding to the input score.\n    If the score is between 90 and 100 (inclusive), returns 'A'.\n    Otherwise, returns 'B'.\n    \"\"\"", "entry_point": "evaluate_integer_grade", "test": "def check(candidate):\n    console.assert(evaluate_integer_grade(90) === 'A')\n    console.assert(evaluate_integer_grade(89) === 'B')\n    console.assert(evaluate_integer_grade(95) === 'A')\n    console.assert(evaluate_integer_grade(100) === 'A')\n    console.assert(evaluate_integer_grade(101) === 'B')\ncheck(evaluate_integer_grade)\n", "given_tests": ["console.assert(evaluate_integer_grade(90) === 'A')"], "solution": "function evaluate_integer_grade(score)\n/**\n Evaluate the grade for an input integer.\n \n Parameters:\n - score (int): The integer score to be evaluated.\n \n Returns:\n char: The grade corresponding to the input score.\n If the score is between 90 and 100 (inclusive), returns 'A'.\n Otherwise, returns 'B'.\n*/\n{\n    // Return 'A' or 'B' based on the condition\n    return ((90 <= score && score <= 100) ? 'A' : 'B');\n}"}
{"task_id": "MBPP_JS/display_ascii_info", "prompt": "def display_ascii_info(...) :\n    \"\"\"\n    Display the ASCII information for a given character.\n\nParameters:\n@param {char} character - The input character for which ASCII information is to be displayed.\n\nReturns:\n@returns {number} - The corresponding ASCII code.\n    \"\"\"", "entry_point": "display_ascii_info", "test": "def check(candidate):\n    console.assert(display_ascii_info('A') === 65)\n    console.assert(display_ascii_info('B') === 66)\n    console.assert(display_ascii_info('0') === 48)\n    console.assert(display_ascii_info(' ') === 32)\ncheck(display_ascii_info)\n", "given_tests": ["console.assert(display_ascii_info('A') === 65)"], "solution": "function display_ascii_info(character)\n/**\n Display the ASCII information for a given character.\n \n Parameters:\n @param {char} character - The input character for which ASCII information is to be displayed.\n \n Returns:\n @returns {number} - The corresponding ASCII code.\n*/\n{\n    return character.charCodeAt(0);\n}"}
{"task_id": "MBPP_JS/countPermutationsOfBinaryString", "prompt": "def countPermutationsOfBinaryString(...) :\n    \"\"\"\n    Count the number of different permutation schemes for a binary string of length n, where the number of '1's is m and the number of '0's is n - m.\n\nParameters:\n@param {number} n - Length of the binary string.\n@param {number} m - Number of '1's in the binary string.\n\nReturns:\n@returns {number} The total number of different permutation schemes.\n    \"\"\"", "entry_point": "countPermutationsOfBinaryString", "test": "def check(candidate):\n    console.assert(countPermutationsOfBinaryString(2, 0) === 2)\n    console.assert(countPermutationsOfBinaryString(2, 1) === 0)\n    console.assert(countPermutationsOfBinaryString(3, 0) === 0)\n    console.assert(countPermutationsOfBinaryString(3, 1) === 3)\n    console.assert(countPermutationsOfBinaryString(3, 2) === 0)\n    console.assert(countPermutationsOfBinaryString(30, 2) === 145422675)\n    console.assert(countPermutationsOfBinaryString(4, 2) === 4)\n    console.assert(countPermutationsOfBinaryString(5, 5) === 1)\n    console.assert(countPermutationsOfBinaryString(33, 17) === 13884156)\n    console.assert(countPermutationsOfBinaryString(1000, 1000) === 1)\ncheck(countPermutationsOfBinaryString)\n", "given_tests": ["console.assert(countPermutationsOfBinaryString(2, 0) === 2)"], "solution": "function countPermutationsOfBinaryString(n, m)\n/**\n Count the number of different permutation schemes for a binary string of length n, where the number of '1's is m and the number of '0's is n - m.\n \n Parameters:\n @param {number} n - Length of the binary string.\n @param {number} m - Number of '1's in the binary string.\n \n Returns:\n @returns {number} The total number of different permutation schemes.\n*/\n{\n    let factorial = 1;\n    let i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    let numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    let denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    let denominator2 = factorial; // ((n-m)/2)!\n\n    // Check for edge cases\n    if ((n + m) % 2 === 1) {\n        return 0;\n    } else if (n === m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return Math.round(numerator / denominator1 / denominator2);\n    }\n}"}
{"task_id": "MBPP_JS/maxModeSum", "prompt": "def maxModeSum(...) :\n    \"\"\"\n    Given n positive integers representing the count of each number from 1 to n, find the maximum sum of the mode (most frequent element) for all prefixes of a sequence constructed from these numbers. The mode is the largest number among the most frequent elements in a sequence.\n    \"\"\"", "entry_point": "maxModeSum", "test": "def check(candidate):\n    console.assert(maxModeSum(3, [1, 3, 2]) === 17)\n    console.assert(maxModeSum(4, [4, 1, 2, 3]) === 37)\n    console.assert(maxModeSum(2, [1, 1]) === 4)\n    console.assert(maxModeSum(5, [1, 2, 3, 4, 5]) === 75)\n    console.assert(maxModeSum(1, [100000]) === 100000)\n    console.assert(maxModeSum(5, [5, 3, 2, 4, 1]) === 62)\n    console.assert(maxModeSum(3, [100000, 100000, 100000]) === 900000)\n    console.assert(maxModeSum(3, [2, 2, 5]) === 27)\n    console.assert(maxModeSum(4, [4, 4, 4, 4]) === 64)\n    console.assert(maxModeSum(6, [1, 2, 3, 4, 5, 6]) === 126)\n    console.assert(maxModeSum(3, [3, 1, 2]) === 16)\ncheck(maxModeSum)\n", "given_tests": ["console.assert(maxModeSum(3, [1, 3, 2]) === 17)"], "solution": "function maxModeSum(n, counts)\n/**\n Given n positive integers representing the count of each number from 1 to n, find the maximum sum of the mode (most frequent element) for all prefixes of a sequence constructed from these numbers. The mode is the largest number among the most frequent elements in a sequence.\n*/\n{\n  let ans = 0;\n  let mx = 0;\n  let f = new Array(100000).fill(0); // Initialize the array with zeroes\n\n  for (let i = 0; i <= n; ++i) {\n    f[i] = 0;\n  }\n\n  for (let i = n; i > 0; --i) {\n    while (mx < counts[i - 1]) {\n      mx++;\n      f[mx] = f[mx - 1] + i;\n    }\n    ans += f[counts[i - 1]];\n  }\n  return ans;\n}"}
{"task_id": "MBPP_JS/count_coloring_methods", "prompt": "def count_coloring_methods(...) :\n    \"\"\"\n    Counts the number of different coloring methods for n squares with m colors,\nconsidering the requirement that adjacent squares and the first/last squares\nmust have different colors.\nParameters:\n- n (number): The number of squares.\n- m (number): The number of colors.\nReturns:\n- number: The count of different coloring methods satisfying the conditions,\n           result is modulo 1000003.\n    \"\"\"", "entry_point": "count_coloring_methods", "test": "def check(candidate):\n    console.assert(count_coloring_methods(1, 1) === 1)\n    console.assert(count_coloring_methods(2, 2) === 2)\n    console.assert(count_coloring_methods(3, 3) === 6)\n    console.assert(count_coloring_methods(4, 2) === 2)\n    console.assert(count_coloring_methods(2, 3) === 6)\n    console.assert(count_coloring_methods(1000, 1000) === 67911)\n    console.assert(count_coloring_methods(999, 66) === 501817)\n    console.assert(count_coloring_methods(5, 3) === 30)\ncheck(count_coloring_methods)\n", "given_tests": ["console.assert(count_coloring_methods(1, 1) === 1)"], "solution": "function count_coloring_methods(n, m)\n/**\n Counts the number of different coloring methods for n squares with m colors,\n considering the requirement that adjacent squares and the first/last squares\n must have different colors.\n Parameters:\n - n (number): The number of squares.\n - m (number): The number of colors.\n Returns:\n - number: The count of different coloring methods satisfying the conditions,\n result is modulo 1000003.\n*/\n{\n    const MOD = 1000003;\n    let f = new Array(1111); // Array to store results\n    if (n === 1) return m;\n    if (n === 2) return (m * (m - 1)) % MOD;\n\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (m * (m - 1)) % MOD;\n    // Formula derived from the given gold.c code\n    f[3] = (f[2] * (m - 2)) % MOD;\n\n    for (let i = 4; i <= n; i++) {\n        f[i] = ((f[i - 1] * (m - 2)) % MOD +\n                (f[i - 2] * (m - 1)) % MOD) % MOD;\n    }\n    return f[n];\n}"}
{"task_id": "MBPP_JS/addDigits", "prompt": "def addDigits(...) :\n    \"\"\"\n    Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.\n    \"\"\"", "entry_point": "addDigits", "test": "def check(candidate):\n    console.assert(addDigits(38) === 2)\n    console.assert(addDigits(0) === 0)\n    console.assert(addDigits(9) === 9)\n    console.assert(addDigits(123) === 6)\n    console.assert(addDigits(456) === 6)\n    console.assert(addDigits(9999) === 9)\n    console.assert(addDigits(100) === 1)\n    console.assert(addDigits(1010) === 2)\n    console.assert(addDigits(1234) === 1)\n    console.assert(addDigits(9876) === 3)\n    console.assert(addDigits(199) === 1)\ncheck(addDigits)\n", "given_tests": ["console.assert(addDigits(38) === 2)"], "solution": "function addDigits(num)\n/**\n Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.\n*/\n{\n    while (num >= 10) {\n        let sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num = Math.floor(num / 10);\n        }\n        num = sum;\n    }\n    return num;\n}"}
{"task_id": "MBPP_JS/createId", "prompt": "def createId(...) :\n    \"\"\"\n    Creates an ID by combining two strings in a specific manner.\nParameters:\n- word1 (string): The first string to be used in the ID.\n- word2 (string): The second string to be used in the ID.\nReturns:\nstring: A divine ID formed by reversing every other character of the second string and combining it with the first string.\n    \"\"\"", "entry_point": "createId", "test": "def check(candidate):\n    console.assert(createId(\"fish\", \"cat\") === \"ftiasch\")\n    console.assert(createId(\"icpc\", \"acm\") === \"imccpac\")\n    console.assert(createId(\"oo\", \"w\") === \"owo\")\n    console.assert(createId(\"hello\", \"world\") === \"hdellrloow\")\n    console.assert(createId(\"abc\", \"def\") === \"afbecd\")\n    console.assert(createId(\"buaanb\", \"nbbuaa\") === \"bauaauabnbbn\")\n    console.assert(createId(\"xtuisgood\", \"ilovextu\") === \"xuttuxiesvgooloid\")\ncheck(createId)\n", "given_tests": ["console.assert(createId(\"fish\", \"cat\") === \"ftiasch\")"], "solution": "function createId(word1, word2)\n/**\n Creates an ID by combining two strings in a specific manner.\n Parameters:\n - word1 (string): The first string to be used in the ID.\n - word2 (string): The second string to be used in the ID.\n Returns:\n string: A divine ID formed by reversing every other character of the second string and combining it with the first string.\n*/\n{\n    let id = '';\n    for (let i = 0, k = 0, j = word2.length - 1; i < word1.length + word2.length; i++) {\n        if (i % 2 === 0) {\n            id += word1.charAt(k++); // Take character from word1\n        } else {\n            id += word2.charAt(j--); // Take character from word2 in reverse\n        }\n    }\n    return id;\n}"}
{"task_id": "MBPP_JS/makeEqualAgain", "prompt": "def makeEqualAgain(...) :\n    \"\"\"\n    You are given an array a of n integers. You can perform at most one operation where\nyou select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j]\nwith x, at a cost of (j - i + 1).\nFind the minimum cost to make all elements in the array equal.\n    \"\"\"", "entry_point": "makeEqualAgain", "test": "def check(candidate):\n    console.assert(makeEqualAgain(6, [1, 2, 3, 4, 5, 1]) === 4)\n    console.assert(makeEqualAgain(7, [1, 1, 1, 1, 1, 1, 1]) === 0)\n    console.assert(makeEqualAgain(8, [8, 8, 8, 1, 2, 8, 8, 8]) === 2)\n    console.assert(makeEqualAgain(3, [1, 2, 3]) === 2)\n    console.assert(makeEqualAgain(7, [4, 3, 2, 7, 1, 1, 3]) === 6)\n    console.assert(makeEqualAgain(9, [9, 9, 2, 9, 2, 5, 5, 5, 3]) === 7)\n    console.assert(makeEqualAgain(3, [1, 2, 1]) === 1)\n    console.assert(makeEqualAgain(5, [5, 5, 1, 5, 5]) === 1)\n    console.assert(makeEqualAgain(4, [1, 1, 1, 1]) === 0)\n    console.assert(makeEqualAgain(6, [2, 2, 2, 3, 2, 2]) === 1)\n    console.assert(makeEqualAgain(1, [1]) === 0)\n    console.assert(makeEqualAgain(2, [1, 2]) === 1)\n    console.assert(makeEqualAgain(4, [1, 2, 2, 1]) === 2)\n    console.assert(makeEqualAgain(7, [4, 4, 4, 3, 3, 4, 4]) === 2)\n    console.assert(makeEqualAgain(6, [5, 4, 4, 4, 5, 5]) === 3)\n    console.assert(makeEqualAgain(7, [1, 2, 1, 2, 1, 2, 1]) === 5)\ncheck(makeEqualAgain)\n", "given_tests": ["console.assert(makeEqualAgain(6, [1, 2, 3, 4, 5, 1]) === 4)"], "solution": "function makeEqualAgain(n, a)\n/**\n You are given an array a of n integers. You can perform at most one operation where\n you select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j]\n with x, at a cost of (j - i + 1).\n Find the minimum cost to make all elements in the array equal.\n*/\n{\n    let j = 0, p = 1, q = 0, c, d;\n    let k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] !== a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] !== a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] !== a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] !== a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}"}
{"task_id": "MBPP_JS/countBalancedSubsequences", "prompt": "def countBalancedSubsequences(...) :\n    \"\"\"\n    Given three integers n, m, and k, find the number of sequences consisting of n '(' and m ')', such that the longest balanced subsequence is of length 2 * k. The result should be calculated modulo 1,000,000,007 (10^9 + 7).\n    \"\"\"", "entry_point": "countBalancedSubsequences", "test": "def check(candidate):\n    console.assert(countBalancedSubsequences(2, 2, 2) === 2)\n    console.assert(countBalancedSubsequences(3, 2, 3) === 0)\n    console.assert(countBalancedSubsequences(3, 2, 1) === 4)\n    console.assert(countBalancedSubsequences(4, 3, 2) === 14)\n    console.assert(countBalancedSubsequences(5, 5, 2) === 35)\n    console.assert(countBalancedSubsequences(6, 1, 1) === 6)\n    console.assert(countBalancedSubsequences(1, 6, 1) === 6)\n    console.assert(countBalancedSubsequences(7, 2, 2) === 27)\n    console.assert(countBalancedSubsequences(8, 3, 3) === 110)\n    console.assert(countBalancedSubsequences(10, 10, 5) === 10659)\n    console.assert(countBalancedSubsequences(20, 20, 10) === 574221648)\n    console.assert(countBalancedSubsequences(2000, 2000, 1000) === 854104531)\n    console.assert(countBalancedSubsequences(2000, 1999, 1000) === 334874485)\n    console.assert(countBalancedSubsequences(2000, 2000, 1999) === 259428024)\ncheck(countBalancedSubsequences)\n", "given_tests": ["console.assert(countBalancedSubsequences(2, 2, 2) === 2)"], "solution": "function countBalancedSubsequences(n, m, k)\n/**\n Given three integers n, m, and k, find the number of sequences consisting of n '(' and m ')', such that the longest balanced subsequence is of length 2 * k. The result should be calculated modulo 1,000,000,007 (10^9 + 7).\n*/\n{\n    const P = 1e9 + 7;\n    const C = Array.from({ length: 4003 }, () => Array(4003).fill(0));\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] === 0) {\n        for (let i = 0; i <= 4002; i++) C[i][0] = 1;\n        for (let i = 1; i <= 4002; i++)\n            for (let j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    \n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}"}
{"task_id": "MBPP_JS/calculateDistance", "prompt": "def calculateDistance(...) :\n    \"\"\"\n    Calculate the distance between two points A (xa, ya) and B (xb, yb).\n\nParameters:\n- xa (number): x-coordinate of point A.\n- ya (number): y-coordinate of point A.\n- xb (number): x-coordinate of point B.\n- yb (number): y-coordinate of point B.\n\nReturns:\nnumber: The distance between points A and B.\n    \"\"\"", "entry_point": "calculateDistance", "test": "def check(candidate):\n    console.assert(Math.abs(calculateDistance(0, 0, 3, 4) - 5) < 1e-6)\n    console.assert(Math.abs(calculateDistance(0, 0, 0, 0) - 0) < 1e-6)\n    console.assert(Math.abs(calculateDistance(-1, -1, 2, 2) - 4.242640687) < 1e-6)\n    console.assert(Math.abs(calculateDistance(1.5, 3.9, 4.2, -1.1) - 5.68243) < 1e-6)\ncheck(calculateDistance)\n", "given_tests": ["console.assert(Math.abs(calculateDistance(0, 0, 3, 4) - 5) < 1e-6)"], "solution": "function calculateDistance(xa, ya, xb, yb)\n/**\n Calculate the distance between two points A (xa, ya) and B (xb, yb).\n \n Parameters:\n - xa (number): x-coordinate of point A.\n - ya (number): y-coordinate of point A.\n - xb (number): x-coordinate of point B.\n - yb (number): y-coordinate of point B.\n \n Returns:\n number: The distance between points A and B.\n*/\n{\n    return Math.sqrt(Math.pow(xa - xb, 2) + Math.pow(ya - yb, 2));\n}"}
{"task_id": "MBPP_JS/canWinNim", "prompt": "def canWinNim(...) :\n    \"\"\"\n    You are playing a game called Nim. In this game, you start with a pile of n stones, and you and your opponent take turns to remove 1 to 3 stones from the pile. The one who removes the last stone wins the game. Given the number of stones n, determine if you can win the game if both you and your opponent play optimally. Note: You always take the first turn.\n    \"\"\"", "entry_point": "canWinNim", "test": "def check(candidate):\n    console.assert(canWinNim(1) === true)\n    console.assert(canWinNim(2) === true)\n    console.assert(canWinNim(3) === true)\n    console.assert(canWinNim(4) === false)\n    console.assert(canWinNim(5) === true)\n    console.assert(canWinNim(6) === true)\n    console.assert(canWinNim(7) === true)\n    console.assert(canWinNim(8) === false)\n    console.assert(canWinNim(9) === true)\n    console.assert(canWinNim(10) === true)\n    console.assert(canWinNim(11) === true)\n    console.assert(canWinNim(12) === false)\n    console.assert(canWinNim(13) === true)\n    console.assert(canWinNim(14) === true)\n    console.assert(canWinNim(15) === true)\n    console.assert(canWinNim(16) === false)\n    console.assert(canWinNim(17) === true)\n    console.assert(canWinNim(18) === true)\n    console.assert(canWinNim(19) === true)\n    console.assert(canWinNim(20) === false)\ncheck(canWinNim)\n", "given_tests": ["console.assert(canWinNim(1) === true)"], "solution": "function canWinNim(n)\n/**\n You are playing a game called Nim. In this game, you start with a pile of n stones, and you and your opponent take turns to remove 1 to 3 stones from the pile. The one who removes the last stone wins the game. Given the number of stones n, determine if you can win the game if both you and your opponent play optimally. Note: You always take the first turn.\n*/\n{\n    return n % 4 !== 0;\n}"}
{"task_id": "MBPP_JS/minRoundsToSameChar", "prompt": "def minRoundsToSameChar(...) :\n    \"\"\"\n    Given a string consisting of lowercase English letters, you can change one character to another in each round. This function calculates the minimum number of rounds needed to make the string composed of the same character.\n@param {string} s - The input string.\n@returns {number} The minimum number of rounds to make all characters in the string the same.\n    \"\"\"", "entry_point": "minRoundsToSameChar", "test": "def check(candidate):\n    console.assert(minRoundsToSameChar(\"aab\") === 1)\n    console.assert(minRoundsToSameChar(\"abc\") === 2)\n    console.assert(minRoundsToSameChar(\"aaa\") === 0)\n    console.assert(minRoundsToSameChar(\"abab\") === 1)\n    console.assert(minRoundsToSameChar(\"zzzzz\") === 0)\ncheck(minRoundsToSameChar)\n", "given_tests": ["console.assert(minRoundsToSameChar(\"aab\") === 1)"], "solution": "function minRoundsToSameChar(s)\n/**\n Given a string consisting of lowercase English letters, you can change one character to another in each round. This function calculates the minimum number of rounds needed to make the string composed of the same character.\n @param {string} s - The input string.\n @returns {number} The minimum number of rounds to make all characters in the string the same.\n*/\n{\n    const charCount = new Array(26).fill(0); // Assuming only lowercase letters\n    for (const char of s) {\n        charCount[char.charCodeAt(0) - 'a'.charCodeAt(0)]++;\n    }\n    let maxCount = 0;\n    for (const count of charCount) {\n        if (count !== 0) {\n            maxCount++;\n        }\n    }\n\n    return maxCount - 1;\n}"}
{"task_id": "MBPP_JS/areIntervalsIntersecting", "prompt": "def areIntervalsIntersecting(...) :\n    \"\"\"\n    Determine if two closed intervals intersect.\n\n@param {number} a - Start of the first closed interval, must satisfy 0 <= a <= b <= 1000.\n@param {number} b - End of the first closed interval, must satisfy 0 <= a <= b <= 1000.\n@param {number} c - Start of the second closed interval, must satisfy 0 <= c <= d <= 1000.\n@param {number} d - End of the second closed interval, must satisfy 0 <= c <= d <= 1000.\n@returns {number} 1 if the intervals intersect, 0 otherwise.\n    \"\"\"", "entry_point": "areIntervalsIntersecting", "test": "def check(candidate):\n    console.assert(areIntervalsIntersecting(1, 1, 1, 2) === 1)\n    console.assert(areIntervalsIntersecting(3, 5, 2, 6) === 1)\n    console.assert(areIntervalsIntersecting(3, 5, 4, 7) === 1)\n    console.assert(areIntervalsIntersecting(3, 5, 6, 7) === 0)\n    console.assert(areIntervalsIntersecting(0, 0, 0, 0) === 1)\n    console.assert(areIntervalsIntersecting(1, 3, 2, 4) === 1)\n    console.assert(areIntervalsIntersecting(1, 3, 4, 6) === 0)\n    console.assert(areIntervalsIntersecting(10, 20, 20, 30) === 1)\n    console.assert(areIntervalsIntersecting(10, 20, 21, 30) === 0)\ncheck(areIntervalsIntersecting)\n", "given_tests": ["console.assert(areIntervalsIntersecting(1, 1, 1, 2) === 1)"], "solution": "function areIntervalsIntersecting(a, b, c, d)\n/**\n Determine if two closed intervals intersect.\n \n @param {number} a - Start of the first closed interval, must satisfy 0 <= a <= b <= 1000.\n @param {number} b - End of the first closed interval, must satisfy 0 <= a <= b <= 1000.\n @param {number} c - Start of the second closed interval, must satisfy 0 <= c <= d <= 1000.\n @param {number} d - End of the second closed interval, must satisfy 0 <= c <= d <= 1000.\n @returns {number} 1 if the intervals intersect, 0 otherwise.\n*/\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}"}
{"task_id": "MBPP_JS/maxModeSum", "prompt": "def maxModeSum(...) :\n    \"\"\"\n    Given n positive integers representing the count of each number from 1 to n, find the maximum sum of the mode (most frequent element) for all prefixes of a sequence constructed from these numbers. The mode is the largest number among the most frequent elements in a sequence. .\n    \"\"\"", "entry_point": "maxModeSum", "test": "def check(candidate):\n    console.assert(maxModeSum(3, [1, 3, 2]) === 17)\n    console.assert(maxModeSum(4, [4, 1, 2, 3]) === 37)\n    console.assert(maxModeSum(2, [1, 1]) === 4)\n    console.assert(maxModeSum(5, [1, 2, 3, 4, 5]) === 75)\n    console.assert(maxModeSum(1, [100000]) === 100000)\n    console.assert(maxModeSum(5, [5, 3, 2, 4, 1]) === 62)\n    console.assert(maxModeSum(3, [100000, 100000, 100000]) === 900000)\n    console.assert(maxModeSum(3, [2, 2, 5]) === 27)\n    console.assert(maxModeSum(4, [4, 4, 4, 4]) === 64)\n    console.assert(maxModeSum(6, [1, 2, 3, 4, 5, 6]) === 126)\n    console.assert(maxModeSum(3, [3, 1, 2]) === 16)\ncheck(maxModeSum)\n", "given_tests": ["console.assert(maxModeSum(3, [1, 3, 2]) === 17)"], "solution": "function maxModeSum(n, counts)\n/**\n Given n positive integers representing the count of each number from 1 to n, find the maximum sum of the mode (most frequent element) for all prefixes of a sequence constructed from these numbers. The mode is the largest number among the most frequent elements in a sequence. .\n*/\n{\n  let ans = 0;\n  let mx = 0;\n  let f = new Array(100000).fill(0); // Initialize the array with zeroes\n\n  for (let i = 0; i <= n; ++i) {\n    f[i] = 0;\n  }\n\n  for (let i = n; i > 0; --i) {\n    while (mx < counts[i - 1]) {\n      mx++;\n      f[mx] = f[mx - 1] + i;\n    }\n    ans += f[counts[i - 1]];\n  }\n  return ans;\n}"}
{"task_id": "MBPP_JS/classify_integer", "prompt": "def classify_integer(...) :\n    \"\"\"\n    Classify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until \nthe class is determined.\n\nParameters:\n- x (string): The integer to be classified as a string.\n\nReturns:\nint: The class to which the integer x belongs.\n    \"\"\"", "entry_point": "classify_integer", "test": "def check(candidate):\n    console.assert(classify_integer(\"24\") === 6)\n    console.assert(classify_integer(\"39\") === 3)\n    console.assert(classify_integer(\"123456789\") === 9)\n    console.assert(classify_integer(\"123456789012345678901234567890\") === 9)\n    console.assert(classify_integer(\"12345\") === 6)\n    console.assert(classify_integer(\"999999999\") === 9)\ncheck(classify_integer)\n", "given_tests": ["console.assert(classify_integer(\"24\") === 6)"], "solution": "function classify_integer(x)\n/**\n Classify the integer x based on the following method:\n If x is a single-digit number, x belongs to its own class.\n Otherwise, sum the digits of x, get a new x, and iterate until\n the class is determined.\n \n Parameters:\n - x (string): The integer to be classified as a string.\n \n Returns:\n int: The class to which the integer x belongs.\n*/\n{\n    let n = 0;\n    for (let i = 0; i < x.length; i++) {\n        n += parseInt(x[i], 10);\n    }\n    while (n > 9) {\n        let t = n;\n        let a = 0;\n        while (t) {\n            a += t % 10;\n            t = Math.floor(t / 10);\n        }\n        n = a;\n    }\n    return n;\n}"}
{"task_id": "MBPP_JS/makeEqualAgain", "prompt": "def makeEqualAgain(...) :\n    \"\"\"\n    You are given an array a of n integers. You can perform at most one operation where\nyou select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j]\nwith x, at a cost of (j - i + 1).\nFind the minimum cost to make all elements in the array equal.\n    \"\"\"", "entry_point": "makeEqualAgain", "test": "def check(candidate):\n    console.assert(makeEqualAgain(6, [1, 2, 3, 4, 5, 1]) === 4)\n    console.assert(makeEqualAgain(7, [1, 1, 1, 1, 1, 1, 1]) === 0)\n    console.assert(makeEqualAgain(8, [8, 8, 8, 1, 2, 8, 8, 8]) === 2)\n    console.assert(makeEqualAgain(3, [1, 2, 3]) === 2)\n    console.assert(makeEqualAgain(7, [4, 3, 2, 7, 1, 1, 3]) === 6)\n    console.assert(makeEqualAgain(9, [9, 9, 2, 9, 2, 5, 5, 5, 3]) === 7)\n    console.assert(makeEqualAgain(3, [1, 2, 1]) === 1)\n    console.assert(makeEqualAgain(5, [5, 5, 1, 5, 5]) === 1)\n    console.assert(makeEqualAgain(4, [1, 1, 1, 1]) === 0)\n    console.assert(makeEqualAgain(6, [2, 2, 2, 3, 2, 2]) === 1)\n    console.assert(makeEqualAgain(1, [1]) === 0)\n    console.assert(makeEqualAgain(2, [1, 2]) === 1)\n    console.assert(makeEqualAgain(4, [1, 2, 2, 1]) === 2)\n    console.assert(makeEqualAgain(7, [4, 4, 4, 3, 3, 4, 4]) === 2)\n    console.assert(makeEqualAgain(6, [5, 4, 4, 4, 5, 5]) === 3)\n    console.assert(makeEqualAgain(7, [1, 2, 1, 2, 1, 2, 1]) === 5)\ncheck(makeEqualAgain)\n", "given_tests": ["console.assert(makeEqualAgain(6, [1, 2, 3, 4, 5, 1]) === 4)"], "solution": "function makeEqualAgain(n, a)\n/**\n You are given an array a of n integers. You can perform at most one operation where\n you select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j]\n with x, at a cost of (j - i + 1).\n Find the minimum cost to make all elements in the array equal.\n*/\n{\n    let j = 0, p = 1, q = 0, c, d;\n    let k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] !== a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] !== a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] !== a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] !== a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}"}
{"task_id": "MBPP_JS/countTriplets", "prompt": "def countTriplets(...) :\n    \"\"\"\n    Determines the number of ways to choose a triplet (a, b, c) from an array of distinct integers representing heights such that the greatest common divisor (GCD) of the maximum and minimum values of the triplet is 1.\n    \"\"\"", "entry_point": "countTriplets", "test": "def check(candidate):\n    console.assert(countTriplets([1, 5, 7]) === 1)\n    console.assert(countTriplets([1, 6, 2, 3]) === 3)\n    console.assert(countTriplets([16, 4, 8, 2]) === 0)\n    console.assert(countTriplets([10, 1, 6, 7, 9, 8, 4, 3, 5, 2]) === 77)\n    console.assert(countTriplets([4, 5, 9, 11, 14]) === 7)\n    console.assert(countTriplets([15, 10, 6, 9, 7, 3, 12, 8, 11, 1, 2]) === 104)\n    console.assert(countTriplets([3, 7, 11, 13]) === 4)\n    console.assert(countTriplets([5, 12, 13, 17, 19]) === 10)\n    console.assert(countTriplets([2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]) === 87)\n    console.assert(countTriplets([1, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]) === 122)\ncheck(countTriplets)\n", "given_tests": ["console.assert(countTriplets([1, 5, 7]) === 1)"], "solution": "function countTriplets(heights)\n/**\n Determines the number of ways to choose a triplet (a, b, c) from an array of distinct integers representing heights such that the greatest common divisor (GCD) of the maximum and minimum values of the triplet is 1.\n*/\n{\n    let count = 0;\n    const n = heights.length;\n    for (let i = 0; i < n; ++i) {\n        for (let j = i + 1; j < n; ++j) {\n            for (let k = j + 1; k < n; ++k) {\n                const minVal = Math.min(heights[i], heights[j], heights[k]);\n                const maxVal = Math.max(heights[i], heights[j], heights[k]);\n                if (gcd(minVal, maxVal) === 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\n// Helper function to find the greatest common divisor\nfunction gcd(a, b) {\n    while (b !== 0) {\n        let t = b;\n        b = a % b;\n        a = t;\n    }\n    return a;\n}"}
{"task_id": "MBPP_JS/shiftCharacters", "prompt": "def shiftCharacters(...) :\n    \"\"\"\n    Shifts all characters by 5 positions in alphabetical order.\nOnly letters are replaced, and all letters are in uppercase.\n\nParameters:\n- text (string): The input text to be processed.\n\nReturns:\n- string: The transformed text with characters shifted by 5 positions.\n    \"\"\"", "entry_point": "shiftCharacters", "test": "def check(candidate):\n    console.assert(shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") === \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\")\n    console.assert(shiftCharacters(\"N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ\") === \"I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME\")\n    console.assert(shiftCharacters(\"IFSLJW PSTBX KZQQ BJQQ YMFY HFJXFW NX RTWJ IFSLJWTZX YMFS MJ\") === \"DANGER KNOWS FULL WELL THAT CAESAR IS MORE DANGEROUS THAN HE\")\ncheck(shiftCharacters)\n", "given_tests": ["console.assert(shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") === \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\")"], "solution": "function shiftCharacters(text)\n/**\n Shifts all characters by 5 positions in alphabetical order.\n Only letters are replaced, and all letters are in uppercase.\n \n Parameters:\n - text (string): The input text to be processed.\n \n Returns:\n - string: The transformed text with characters shifted by 5 positions.\n*/\n{\n    let shiftedText = '';\n    for (let i = 0; i < text.length; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            shiftedText += String.fromCharCode(text.charCodeAt(i) + 21); // 'V' - 'A' = 21\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            shiftedText += String.fromCharCode(text.charCodeAt(i) - 5); // 'A' - 'F' = -5\n        } else {\n            shiftedText += text[i];\n        }\n    }\n    return shiftedText;\n}"}
{"task_id": "MBPP_JS/countPermutationsOfBinaryString", "prompt": "def countPermutationsOfBinaryString(...) :\n    \"\"\"\n    Count the number of different permutation schemes for a binary string of length n, where the number of '1's is m and the number of '0's is n - m.\n\nParameters:\n@param {number} n - Length of the binary string.\n@param {number} m - Number of '1's in the binary string.\n\nReturns:\n@returns {number} The total number of different permutation schemes.\n    \"\"\"", "entry_point": "countPermutationsOfBinaryString", "test": "def check(candidate):\n    console.assert(countPermutationsOfBinaryString(2, 0) === 2)\n    console.assert(countPermutationsOfBinaryString(2, 1) === 0)\n    console.assert(countPermutationsOfBinaryString(3, 0) === 0)\n    console.assert(countPermutationsOfBinaryString(3, 1) === 3)\n    console.assert(countPermutationsOfBinaryString(3, 2) === 0)\n    console.assert(countPermutationsOfBinaryString(30, 2) === 145422675)\n    console.assert(countPermutationsOfBinaryString(4, 2) === 4)\n    console.assert(countPermutationsOfBinaryString(5, 5) === 1)\n    console.assert(countPermutationsOfBinaryString(33, 17) === 13884156)\n    console.assert(countPermutationsOfBinaryString(1000, 1000) === 1)\ncheck(countPermutationsOfBinaryString)\n", "given_tests": ["console.assert(countPermutationsOfBinaryString(2, 0) === 2)"], "solution": "function countPermutationsOfBinaryString(n, m)\n/**\n Count the number of different permutation schemes for a binary string of length n, where the number of '1's is m and the number of '0's is n - m.\n \n Parameters:\n @param {number} n - Length of the binary string.\n @param {number} m - Number of '1's in the binary string.\n \n Returns:\n @returns {number} The total number of different permutation schemes.\n*/\n{\n    let factorial = 1;\n    let i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    let numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    let denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    let denominator2 = factorial; // ((n-m)/2)!\n\n    // Check for edge cases\n    if ((n + m) % 2 === 1) {\n        return 0;\n    } else if (n === m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return Math.round(numerator / denominator1 / denominator2);\n    }\n}"}
{"task_id": "MBPP_JS/checkTwoEqualDigits", "prompt": "def checkTwoEqualDigits(...) :\n    \"\"\"\n    Checks if a string with exactly three characters has two characters that are the same.\n\nParameters:\n- str (string): The three-character string to be checked.\n\nReturns:\n- string: Returns 'Yes' if the input has exactly two equal characters, otherwise 'No'.\n    \"\"\"", "entry_point": "checkTwoEqualDigits", "test": "def check(candidate):\n    console.assert(checkTwoEqualDigits(\"112\") === \"Yes\")\n    console.assert(checkTwoEqualDigits(\"123\") === \"No\")\n    console.assert(checkTwoEqualDigits(\"232\") === \"Yes\")\n    console.assert(checkTwoEqualDigits(\"444\") === \"No\"); // All three characters are equal, not two.\n    console.assert(checkTwoEqualDigits(\"121\") === \"Yes\")\n    console.assert(checkTwoEqualDigits(\"787\") === \"Yes\")\n    console.assert(checkTwoEqualDigits(\"999\") === \"No\"); // All three characters are equal\n    console.assert(checkTwoEqualDigits(\"890\") === \"No\")\n    console.assert(checkTwoEqualDigits(\"556\") === \"Yes\")\n    console.assert(checkTwoEqualDigits(\"353\") === \"Yes\"); // No two characters are equal\ncheck(checkTwoEqualDigits)\n", "given_tests": ["console.assert(checkTwoEqualDigits(\"112\") === \"Yes\")"], "solution": "function checkTwoEqualDigits(str)\n/**\n Checks if a string with exactly three characters has two characters that are the same.\n \n Parameters:\n - str (string): The three-character string to be checked.\n \n Returns:\n - string: Returns 'Yes' if the input has exactly two equal characters, otherwise 'No'.\n*/\n{\n    if ((str[0] === str[1] && str[1] !== str[2]) ||\n        (str[0] === str[2] && str[0] !== str[1]) ||\n        (str[1] === str[2] && str[0] !== str[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}"}
{"task_id": "MBPP_JS/processRequest", "prompt": "def processRequest(...) :\n    \"\"\"\n    * Examples:\n * processRequest(1) returns 1\n    \"\"\"", "entry_point": "processRequest", "test": "def check(candidate):\n    console.assert(processRequest(0) === 1)\n    console.assert(processRequest(1) === 1)\n    console.assert(processRequest(2) === 2)\n    console.assert(processRequest(3) === 6)\n    console.assert(processRequest(4) === 24)\n    console.assert(processRequest(10) === 6266)\n    console.assert(processRequest(10000) === 6991)\ncheck(processRequest)\n", "given_tests": ["console.assert(processRequest(0) === 1)"], "solution": "function processRequest(n)\n/**\n * Examples:\n * processRequest(1) returns 1\n*/\n\n{\n\n    const MOD = 10007;\n    let factorials = new Array(10001);\n    factorials[0] = factorials[1] = 1;\n\n\n    for (let i = 2; i <= 10000; i++) {\n        factorials[i] = (factorials[i - 1] * i) % MOD;\n    }\n\n    return factorials[n];\n}"}
{"task_id": "MBPP_JS/countOddNumbers", "prompt": "def countOddNumbers(...) :\n    \"\"\"\n    * countOddNumbers(5, 1, 4, 3, 2, 5) // returns 3\n    \"\"\"", "entry_point": "countOddNumbers", "test": "def check(candidate):\n    console.assert(countOddNumbers(5, 1, 4, 3, 2, 5) === 3)\n    console.assert(countOddNumbers(4, 2, 2, 0, 0) === 0)\n    console.assert(countOddNumbers(6, 7, 7, 8, 1, 9, 10) === 4)\ncheck(countOddNumbers)\n", "given_tests": ["console.assert(countOddNumbers(5, 1, 4, 3, 2, 5) === 3)"], "solution": "function countOddNumbers(count, ...nums)\n/**\n * countOddNumbers(5, 1, 4, 3, 2, 5) // returns 3\n*/\n\n{\n    let ans = 0;\n    for (let i = 0; i < count; i++) {\n        if (nums[i] % 2 !== 0) {\n            ans++;\n        }\n    }\n    return ans;\n}"}
{"task_id": "MBPP_JS/findLongestConsecutiveOnesLength", "prompt": "def findLongestConsecutiveOnesLength(...) :\n    \"\"\"\n    * Examples:\n * findLongestConsecutiveOnesLength(7) === 3\n * findLongestConsecutiveOnesLength(13) === 2\n    \"\"\"", "entry_point": "findLongestConsecutiveOnesLength", "test": "def check(candidate):\n    console.assert(findLongestConsecutiveOnesLength(7) === 3)\n    console.assert(findLongestConsecutiveOnesLength(13) === 2)\n    console.assert(findLongestConsecutiveOnesLength(12345) === 3)\n    console.assert(findLongestConsecutiveOnesLength(0b11011101111) === 4)\n    console.assert(findLongestConsecutiveOnesLength(0xFFFFFFFF) === 32)\n    console.assert(findLongestConsecutiveOnesLength(0) === 0)\ncheck(findLongestConsecutiveOnesLength)\n", "given_tests": ["console.assert(findLongestConsecutiveOnesLength(7) === 3)"], "solution": "function findLongestConsecutiveOnesLength(n)\n/**\n * Examples:\n * findLongestConsecutiveOnesLength(7) === 3\n * findLongestConsecutiveOnesLength(13) === 2\n*/\n\n{\n    let max = 0;\n    let ans = 0;\n    while (n) {\n        if (n & 1)\n            ans++;\n        else {\n            if (ans > max)\n                max = ans;\n            ans = 0;\n        }\n        n >>>= 1;\n    }\n    if (ans > max)\n        max = ans;\n    return max;\n}"}
{"task_id": "MBPP_JS/createId", "prompt": "def createId(...) :\n    \"\"\"\n    * Example usage:\n *   createId('fish','cat') // returns 'ftiasch'\n *   createId('icpc','acm') // returns 'imccpac'\n    \"\"\"", "entry_point": "createId", "test": "def check(candidate):\n    console.assert(createId(\"fish\", \"cat\") === \"ftiasch\")\n    console.assert(createId(\"icpc\", \"acm\") === \"imccpac\")\n    console.assert(createId(\"oo\", \"w\") === \"owo\")\n    console.assert(createId(\"hello\", \"world\") === \"hdellrloow\")\n    console.assert(createId(\"abc\", \"def\") === \"afbecd\")\n    console.assert(createId(\"buaanb\", \"nbbuaa\") === \"bauaauabnbbn\")\n    console.assert(createId(\"xtuisgood\", \"ilovextu\") === \"xuttuxiesvgooloid\")\ncheck(createId)\n", "given_tests": ["console.assert(createId(\"fish\", \"cat\") === \"ftiasch\")"], "solution": "function createId(word1, word2)\n/**\n * Example usage:\n *   createId('fish','cat') // returns 'ftiasch'\n *   createId('icpc','acm') // returns 'imccpac'\n*/\n\n{\n    let id = '';\n    for (let i = 0, k = 0, j = word2.length - 1; i < word1.length + word2.length; i++) {\n        if (i % 2 === 0) {\n            id += word1.charAt(k++); // Take character from word1\n        } else {\n            id += word2.charAt(j--); // Take character from word2 in reverse\n        }\n    }\n    return id;\n}"}
{"task_id": "MBPP_JS/Is_Square", "prompt": "def Is_Square(...) :\n    \"\"\"\n    * Examples:\n * Is_Square(1, [9]) // true\n    \"\"\"", "entry_point": "Is_Square", "test": "def check(candidate):\n    console.assert(Is_Square(1, [9]) === true)\n    console.assert(Is_Square(2, [14, 2]) === true)\n    console.assert(Is_Square(2, [7, 7]) === false)\n    console.assert(Is_Square(7, [1, 2, 3, 4, 5, 6, 7]) === false)\n    console.assert(Is_Square(6, [1, 3, 5, 7, 9, 11]) === true)\n    console.assert(Is_Square(4, [2, 2, 2, 2]) === false)\n    console.assert(Is_Square(3, [4, 5, 6]) === false)\n    console.assert(Is_Square(4, [16, 9, 4, 1]) === false)\n    console.assert(Is_Square(5, [1, 1, 1, 1, 1]) === false)\n    console.assert(Is_Square(2, [25, 25]) === false)\n    console.assert(Is_Square(3, [10, 10, 5]) === true)\ncheck(Is_Square)\n", "given_tests": ["console.assert(Is_Square(1, [9]) === true)"], "solution": "function Is_Square(length, squares)\n/**\n * Examples:\n * Is_Square(1, [9]) // true\n*/\n\n{\n    let sum = 0;\n    for (let i = 0; i < length; ++i) {\n        sum += squares[i]; // Summing the squares\n    }\n    let root = Math.sqrt(sum);\n    return Math.floor(root) === root; // Checking if sum is a perfect square\n}"}
{"task_id": "MBPP_JS/createId", "prompt": "def createId(...) :\n    \"\"\"\n    Creates an ID by combining two strings in a specific manner.\nParameters:\n- word1 (string): The first string to be used in the ID.\n- word2 (string): The second string to be used in the ID.\nReturns:\nstring: A divine ID formed by reversing every other character of the second string and combining it with the first string.\n    \"\"\"", "entry_point": "createId", "test": "def check(candidate):\n    console.assert(createId(\"fish\", \"cat\") === \"ftiasch\")\n    console.assert(createId(\"icpc\", \"acm\") === \"imccpac\")\n    console.assert(createId(\"oo\", \"w\") === \"owo\")\n    console.assert(createId(\"hello\", \"world\") === \"hdellrloow\")\n    console.assert(createId(\"abc\", \"def\") === \"afbecd\")\n    console.assert(createId(\"buaanb\", \"nbbuaa\") === \"bauaauabnbbn\")\n    console.assert(createId(\"xtuisgood\", \"ilovextu\") === \"xuttuxiesvgooloid\")\ncheck(createId)\n", "given_tests": ["console.assert(createId(\"fish\", \"cat\") === \"ftiasch\")"], "solution": "/**\n/**\n Creates an ID by combining two strings in a specific manner.\n Parameters:\n - word1 (string): The first string to be used in the ID.\n - word2 (string): The second string to be used in the ID.\n Returns:\n string: A divine ID formed by reversing every other character of the second string and combining it with the first string.\n*/\n * Creates an ID by combining two strings in a specific manner.\n * Parameters:\n * - word1 (string): The first string to be used in the ID.\n * - word2 (string): The second string to be used in the ID.\n * Returns:\n * string: A divine ID formed by reversing every other character of the second \n *         string and combining it with the first string.\n * Example usage:\n *   createId('fish','cat') // returns 'ftiasch'\n *   createId('icpc','acm') // returns 'imccpac'\n */\nfunction createId(word1, word2)\n\n{\n    let id = '';\n    for (let i = 0, k = 0, j = word2.length - 1; i < word1.length + word2.length; i++) {\n        if (i % 2 === 0) {\n            id += word1.charAt(k++); // Take character from word1\n        } else {\n            id += word2.charAt(j--); // Take character from word2 in reverse\n        }\n    }\n    return id;\n}"}
{"task_id": "MBPP_JS/minRoundsToSameChar", "prompt": "def minRoundsToSameChar(...) :\n    \"\"\"\n    Given a string consisting of lowercase English letters, you can change one character to another in each round. This function calculates the minimum number of rounds needed to make the string composed of the same character.\n@param {string} s - The input string.\n@returns {number} The minimum number of rounds to make all characters in the string the same.\n    \"\"\"", "entry_point": "minRoundsToSameChar", "test": "def check(candidate):\n    console.assert(minRoundsToSameChar(\"aab\") === 1)\n    console.assert(minRoundsToSameChar(\"abc\") === 2)\n    console.assert(minRoundsToSameChar(\"aaa\") === 0)\n    console.assert(minRoundsToSameChar(\"abab\") === 1)\n    console.assert(minRoundsToSameChar(\"zzzzz\") === 0)\ncheck(minRoundsToSameChar)\n", "given_tests": ["console.assert(minRoundsToSameChar(\"aab\") === 1)"], "solution": "/**\n/**\n Given a string consisting of lowercase English letters, you can change one character to another in each round. This function calculates the minimum number of rounds needed to make the string composed of the same character.\n @param {string} s - The input string.\n @returns {number} The minimum number of rounds to make all characters in the string the same.\n*/\n * Given a string consisting of lowercase English letters, you can change one character to another\n * in each round. This function calculates the minimum number of rounds needed to make the string\n * composed of the same character.\n * @param {string} s - The input string.\n * @returns {number} The minimum number of rounds to make all characters in the string the same.\n *\n * Examples:\n * minRoundsToSameChar(\"aab\") // returns 1\n * minRoundsToSameChar(\"abc\") // returns 2\n * minRoundsToSameChar(\"aaa\") // returns 0\n */\nfunction minRoundsToSameChar(s)\n\n{\n    const charCount = new Array(26).fill(0); // Assuming only lowercase letters\n    for (const char of s) {\n        charCount[char.charCodeAt(0) - 'a'.charCodeAt(0)]++;\n    }\n    let maxCount = 0;\n    for (const count of charCount) {\n        if (count !== 0) {\n            maxCount++;\n        }\n    }\n\n    return maxCount - 1;\n}"}
{"task_id": "MBPP_JS/unknown_function", "prompt": "def unknown_function(...) :\n    \"\"\"\n    Given a permutation q of n elements and an integer k, find the number of permutations p of n elements\n such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by\n dividing p into exactly k non-empty contiguous segments and sorting each segment (i.e., choose k-1\n breakpoints 1 <= x1 < x2 < ... < x(k-1) < n, and divide it into [1, x1], (x1, x2], ..., (x(k-1), n]).\n The result should be modulo 998244353.\n    \"\"\"", "entry_point": "unknown_function", "test": "def check(candidate):\n    console.assert(countPermutations(2, 1, [1, 2]) === 2)\n    console.assert(countPermutations(3, 3, [3, 1, 2]) === 1)\n    console.assert(countPermutations(6, 3, [1, 2, 3, 6, 5, 4]) === 13)\n    console.assert(countPermutations(6, 1, [1, 2, 3, 4, 5, 6]) === 720)\n    console.assert(countPermutations(6, 3, [1, 2, 5, 3, 4, 5]) === 0)\n    console.assert(countPermutations(9, 9, [1, 2, 3, 4, 5, 6, 7, 8, 9]) === 1)\n    console.assert(countPermutations(9, 2, [1, 2, 3, 4, 5, 6, 7, 9, 8]) === 29093)\ncheck(unknown_function)\n", "given_tests": ["console.assert(countPermutations(2, 1, [1, 2]) === 2)"], "solution": "/**\n/**\n Given a permutation q of n elements and an integer k, find the number of permutations p of n elements\n such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by\n dividing p into exactly k non-empty contiguous segments and sorting each segment (i.e., choose k-1\n breakpoints 1 <= x1 < x2 < ... < x(k-1) < n, and divide it into [1, x1], (x1, x2], ..., (x(k-1), n]).\n The result should be modulo 998244353.\n*/\n * Given a permutation q of n elements and an integer k, find the number of permutations p of n elements\n * such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by\n * dividing p into exactly k non-empty contiguous segments and sorting each segment (i.e., choose k-1\n * breakpoints 1 <= x1 < x2 < ... < x(k-1) < n, and divide it into [1, x1], (x1, x2], ..., (x(k-1), n]).\n * The result should be modulo 998244353.\n * \n * @example\n * countPermutations(2, 1, [1, 2])\n * // returns 2\n */\nconst countPermutations = (n, k, q) => {\n\nconst P = 998244353;\n    let dp = Array.from({length: n + 1}, () => new Array(n + 1).fill(0));\n    let jc = new Array(n + 1).fill(0);\n    let f = new Array(n + 1).fill(0);\n    \n    dp[0][0] = f[0] = jc[0] = 1;\n    \n    for (let i = 1; i <= n; i++) {\n        jc[i] = (jc[i - 1] * i) % P;\n    }\n    \n    for (let i = 1; i <= n; i++) {\n        f[i] = jc[i];\n        for (let j = 1; j < i; j++) {\n            f[i] = (f[i] + P - (f[j] * jc[i - j]) % P) % P;\n        }\n    }\n    \n    for (let i = 1; i <= n; i++) {\n        for (let j = 0; j < i; j++) {\n            for (let kk = 1; kk <= n; kk++) {\n                dp[i][kk] = (dp[i][kk] + dp[j][kk - 1] * f[i - j]) % P;\n            }\n        }\n    }\n    \n    let m = 0;\n    for (let i = 1; i < n; i++) {\n        if (q[i - 1] > q[i]) {\n            m = i;\n            break;\n        }\n    }\n    \n    let ans = 0;\n    if (m === n || m === 0) {\n        for (let i = k; i <= n; i++) {\n            ans = (ans + dp[n][i]) % P;\n        }\n    } else {\n        for (let i = m + 1; i <= n; i++) {\n            if (i !== m + 1 && (q[i - 2] > q[i - 1] || q[i - 1] < q[m - 1])) {\n                break;\n            }\n            let c = k - 1 + i - n;\n            if (c >= 0) {\n                ans = (ans + dp[m][c] * jc[i - m - 1]) % P;\n            }\n        }\n    }\n    \n    return ans;\n};"}
{"task_id": "MBPP_JS/calculate_triangle_area", "prompt": "def calculate_triangle_area(...) :\n    \"\"\"\n    Calculate the area of a triangle given its three sides.\n\nParameters:\n- a (number): Length of side 'a'.\n- b (number): Length of side 'b'.\n- c (number): Length of side 'c'.\n\nReturns:\n- string|number: If the provided sides form a triangle, return the calculated area with 2 decimal places. Otherwise, return -1.\n    \"\"\"", "entry_point": "calculate_triangle_area", "test": "def check(candidate):\n    console.assert(Math.abs(calculate_triangle_area(3, 5, 4) - 6) < 1e-6)\n    console.assert(calculate_triangle_area(1, 1, 4) === -1)\n    console.assert(Math.abs(calculate_triangle_area(7, 24, 25) - 84) < 1e-6)\n    console.assert(Math.abs(calculate_triangle_area(10.5, 6.2, 7.3) - 22.15) < 1e-6)\ncheck(calculate_triangle_area)\n", "given_tests": ["console.assert(Math.abs(calculate_triangle_area(3, 5, 4) - 6) < 1e-6)"], "solution": "/**\n/**\n Calculate the area of a triangle given its three sides.\n \n Parameters:\n - a (number): Length of side 'a'.\n - b (number): Length of side 'b'.\n - c (number): Length of side 'c'.\n \n Returns:\n - string|number: If the provided sides form a triangle, return the calculated area with 2 decimal places. Otherwise, return -1.\n*/\n * Calculate the area of a triangle given its three sides.\n * \n * @param {number} a - Length of side 'a'.\n * @param {number} b - Length of side 'b'.\n * @param {number} c - Length of side 'c'.\n * @returns {string|number} If the provided sides form a triangle, return the calculated area with 2 decimal places. Otherwise, return -1.\n * Example:\n *  calculate_triangle_area(3, 5, 4) // returns 6\n */\nfunction calculate_triangle_area(a, b, c)\n\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        let s = (a + b + c) / 2.0;\n        return Number(Math.sqrt(s * (s - a) * (s - b) * (s - c)).toFixed(2));\n    } else {\n        return -1; // Use a special value to indicate not a triangle\n    }\n}"}
{"task_id": "MBPP_JS/findMaxMin", "prompt": "def findMaxMin(...) :\n    \"\"\"\n    Find the maximum and minimum of three distinct integers.\n\nParameters:\n- a (number): The first integer.\n- b (number): The second integer.\n- c (number): The third integer.\n\nReturns:\n- Object: An object with properties 'max' and 'min'.\n    \"\"\"", "entry_point": "findMaxMin", "test": "def check(candidate):\n    console.assert(result.max === 3 && result.min === 1)\n    console.assert(result.max === 5 && result.min === 3)\n    console.assert(result.max === 10 && result.min === -2)\n    console.assert(result.max === -1 && result.min === -3)\ncheck(findMaxMin)\n", "given_tests": ["console.assert(result.max === 3 && result.min === 1)"], "solution": "/**\n/**\n Find the maximum and minimum of three distinct integers.\n \n Parameters:\n - a (number): The first integer.\n - b (number): The second integer.\n - c (number): The third integer.\n \n Returns:\n - Object: An object with properties 'max' and 'min'.\n*/\n * Find the maximum and minimum of three distinct integers.\n *\n * Parameters:\n * a (number): The first integer.\n * b (number): The second integer.\n * c (number): The third integer.\n *\n * Returns:\n * Object: An object with properties 'max' and 'min'.\n *\n * Example call:\n * const result = findMaxMin(1, 2, 3);\n * console.assert(result.max === 3 && result.min === 1);\n */\nfunction findMaxMin(a, b, c)\n\n{\n    let max, min;\n    \n    if (a > b) {\n        if (a > c) {\n            max = a;\n            min = (b < c) ? b : c;\n        } else {\n            max = c;\n            min = b;\n        }\n    } else {\n        if (b > c) {\n            max = b;\n            min = (a < c) ? a : c;\n        } else {\n            max = c;\n            min = a;\n        }\n    }\n\n    return { max, min };\n}"}
{"task_id": "MBPP_JS/minRoundsToSameChar", "prompt": "def minRoundsToSameChar(...) :\n    \"\"\"\n    Given a string consisting of lowercase English letters, you can change one character to another in each round. This function calculates the minimum number of rounds needed to make the string composed of the same character.\n@param {string} s - The input string.\n@returns {number} The minimum number of rounds to make all characters in the string the same.\n    \"\"\"", "entry_point": "minRoundsToSameChar", "test": "def check(candidate):\n    console.assert(minRoundsToSameChar(\"aab\") === 1)\n    console.assert(minRoundsToSameChar(\"abc\") === 2)\n    console.assert(minRoundsToSameChar(\"aaa\") === 0)\n    console.assert(minRoundsToSameChar(\"abab\") === 1)\n    console.assert(minRoundsToSameChar(\"zzzzz\") === 0)\ncheck(minRoundsToSameChar)\n", "given_tests": ["console.assert(minRoundsToSameChar(\"aab\") === 1)"], "solution": "/**\n/**\n Given a string consisting of lowercase English letters, you can change one character to another in each round. This function calculates the minimum number of rounds needed to make the string composed of the same character.\n @param {string} s - The input string.\n @returns {number} The minimum number of rounds to make all characters in the string the same.\n*/\n * Given a string consisting of lowercase English letters, you can change one character to another\n * in each round. This function calculates the minimum number of rounds needed to make the string\n * composed of the same character.\n * @param {string} s - The input string.\n * @returns {number} The minimum number of rounds to make all characters in the string the same.\n *\n * Examples:\n * minRoundsToSameChar(\"aab\") // returns 1\n * minRoundsToSameChar(\"abc\") // returns 2\n * minRoundsToSameChar(\"aaa\") // returns 0\n */\nfunction minRoundsToSameChar(s)\n\n{\n    const charCount = new Array(26).fill(0); // Assuming only lowercase letters\n    for (const char of s) {\n        charCount[char.charCodeAt(0) - 'a'.charCodeAt(0)]++;\n    }\n    let maxCount = 0;\n    for (const count of charCount) {\n        if (count !== 0) {\n            maxCount++;\n        }\n    }\n\n    return maxCount - 1;\n}"}
{"task_id": "MBPP_JS/countTriplets", "prompt": "def countTriplets(...) :\n    \"\"\"\n    Determines the number of ways to choose a triplet (a, b, c) from an array of distinct integers representing heights such that the greatest common divisor (GCD) of the maximum and minimum values of the triplet is 1.\n    \"\"\"", "entry_point": "countTriplets", "test": "def check(candidate):\n    console.assert(countTriplets([1, 5, 7]) === 1)\n    console.assert(countTriplets([1, 6, 2, 3]) === 3)\n    console.assert(countTriplets([16, 4, 8, 2]) === 0)\n    console.assert(countTriplets([10, 1, 6, 7, 9, 8, 4, 3, 5, 2]) === 77)\n    console.assert(countTriplets([4, 5, 9, 11, 14]) === 7)\n    console.assert(countTriplets([15, 10, 6, 9, 7, 3, 12, 8, 11, 1, 2]) === 104)\n    console.assert(countTriplets([3, 7, 11, 13]) === 4)\n    console.assert(countTriplets([5, 12, 13, 17, 19]) === 10)\n    console.assert(countTriplets([2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]) === 87)\n    console.assert(countTriplets([1, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]) === 122)\ncheck(countTriplets)\n", "given_tests": ["console.assert(countTriplets([1, 5, 7]) === 1)"], "solution": "/**\n/**\n Determines the number of ways to choose a triplet (a, b, c) from an array of distinct integers representing heights such that the greatest common divisor (GCD) of the maximum and minimum values of the triplet is 1.\n*/\n * Determines the number of ways to choose a triplet (a, b, c) \n * from an array of distinct integers representing heights such that the \n * greatest common divisor (GCD) of the maximum and minimum values \n * of the triplet is 1.\n * \n * @example\n * countTriplets([1, 5, 7])\n * // Returns: 1\n */\nfunction countTriplets(heights)\n\n{\n    let count = 0;\n    const n = heights.length;\n    for (let i = 0; i < n; ++i) {\n        for (let j = i + 1; j < n; ++j) {\n            for (let k = j + 1; k < n; ++k) {\n                const minVal = Math.min(heights[i], heights[j], heights[k]);\n                const maxVal = Math.max(heights[i], heights[j], heights[k]);\n                if (gcd(minVal, maxVal) === 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\n// Helper function to find the greatest common divisor\nfunction gcd(a, b) {\n    while (b !== 0) {\n        let t = b;\n        b = a % b;\n        a = t;\n    }\n    return a;\n}"}
{"task_id": "MBPP_JS/count_coloring_methods", "prompt": "def count_coloring_methods(...) :\n    \"\"\"\n    Counts the number of different coloring methods for n squares with m colors,\nconsidering the requirement that adjacent squares and the first/last squares\nmust have different colors.\nParameters:\n- n (number): The number of squares.\n- m (number): The number of colors.\nReturns:\n- number: The count of different coloring methods satisfying the conditions,\n           result is modulo 1000003.\n    \"\"\"", "entry_point": "count_coloring_methods", "test": "def check(candidate):\n    console.assert(count_coloring_methods(1, 1) === 1)\n    console.assert(count_coloring_methods(2, 2) === 2)\n    console.assert(count_coloring_methods(3, 3) === 6)\n    console.assert(count_coloring_methods(4, 2) === 2)\n    console.assert(count_coloring_methods(2, 3) === 6)\n    console.assert(count_coloring_methods(1000, 1000) === 67911)\n    console.assert(count_coloring_methods(999, 66) === 501817)\n    console.assert(count_coloring_methods(5, 3) === 30)\ncheck(count_coloring_methods)\n", "given_tests": ["console.assert(count_coloring_methods(1, 1) === 1)"], "solution": "// No need to import modules in JavaScript like in C\n/**\n Counts the number of different coloring methods for n squares with m colors,\n considering the requirement that adjacent squares and the first/last squares\n must have different colors.\n Parameters:\n - n (number): The number of squares.\n - m (number): The number of colors.\n Returns:\n - number: The count of different coloring methods satisfying the conditions,\n result is modulo 1000003.\n*/\n/**\n * Counts the number of different coloring methods for n squares with m colors,\n * considering the requirement that adjacent squares and the first/last squares\n * must have different colors.\n * @param {number} n - The number of squares.\n * @param {number} m - The number of colors.\n * @return {number} The count of different coloring methods satisfying the conditions,\n *                  result is modulo 1000003.\n * Example:\n * count_coloring_methods(1,1) // 1\n * count_coloring_methods(2,3) // 6\n */\nfunction count_coloring_methods(n, m)\n\n{\n    const MOD = 1000003;\n    let f = new Array(1111); // Array to store results\n    if (n === 1) return m;\n    if (n === 2) return (m * (m - 1)) % MOD;\n\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (m * (m - 1)) % MOD;\n    // Formula derived from the given gold.c code\n    f[3] = (f[2] * (m - 2)) % MOD;\n\n    for (let i = 4; i <= n; i++) {\n        f[i] = ((f[i - 1] * (m - 2)) % MOD +\n                (f[i - 2] * (m - 1)) % MOD) % MOD;\n    }\n    return f[n];\n}"}
{"task_id": "MBPP_JS/evaluate_integer_grade", "prompt": "def evaluate_integer_grade(...) :\n    \"\"\"\n    Evaluate the grade for an input integer.\n\nParameters:\n- score (int): The integer score to be evaluated.\n\nReturns:\n    char: The grade corresponding to the input score.\n    If the score is between 90 and 100 (inclusive), returns 'A'.\n    Otherwise, returns 'B'.\n    \"\"\"", "entry_point": "evaluate_integer_grade", "test": "def check(candidate):\n    console.assert(evaluate_integer_grade(90) === 'A')\n    console.assert(evaluate_integer_grade(89) === 'B')\n    console.assert(evaluate_integer_grade(95) === 'A')\n    console.assert(evaluate_integer_grade(100) === 'A')\n    console.assert(evaluate_integer_grade(101) === 'B')\ncheck(evaluate_integer_grade)\n", "given_tests": ["console.assert(evaluate_integer_grade(90) === 'A')"], "solution": "/**\n/**\n Evaluate the grade for an input integer.\n \n Parameters:\n - score (int): The integer score to be evaluated.\n \n Returns:\n char: The grade corresponding to the input score.\n If the score is between 90 and 100 (inclusive), returns 'A'.\n Otherwise, returns 'B'.\n*/\n * Evaluate the grade for an input integer.\n * \n * Parameters:\n * - score (int): The integer score to be evaluated.\n * \n * Returns:\n *   char: The grade corresponding to the input score.\n *        If the score is between 90 and 100 (inclusive), returns 'A'.\n *        Otherwise, returns 'B'.\n * \n * @example\n * evaluate_integer_grade(90) // returns 'A'\n */\nfunction evaluate_integer_grade(score)\n\n{\n    // Return 'A' or 'B' based on the condition\n    return ((90 <= score && score <= 100) ? 'A' : 'B');\n}"}
{"task_id": "MBPP_JS/maxModeSum", "prompt": "def maxModeSum(...) :\n    \"\"\"\n    Given n positive integers representing the count of each number from 1 to n, find the maximum sum of the mode (most frequent element) for all prefixes of a sequence constructed from these numbers. The mode is the largest number among the most frequent elements in a sequence.\n    \"\"\"", "entry_point": "maxModeSum", "test": "def check(candidate):\n    console.assert(maxModeSum(3, [1, 3, 2]) === 17)\n    console.assert(maxModeSum(4, [4, 1, 2, 3]) === 37)\n    console.assert(maxModeSum(2, [1, 1]) === 4)\n    console.assert(maxModeSum(5, [1, 2, 3, 4, 5]) === 75)\n    console.assert(maxModeSum(1, [100000]) === 100000)\n    console.assert(maxModeSum(5, [5, 3, 2, 4, 1]) === 62)\n    console.assert(maxModeSum(3, [100000, 100000, 100000]) === 900000)\n    console.assert(maxModeSum(3, [2, 2, 5]) === 27)\n    console.assert(maxModeSum(4, [4, 4, 4, 4]) === 64)\n    console.assert(maxModeSum(6, [1, 2, 3, 4, 5, 6]) === 126)\n    console.assert(maxModeSum(3, [3, 1, 2]) === 16)\ncheck(maxModeSum)\n", "given_tests": ["console.assert(maxModeSum(3, [1, 3, 2]) === 17)"], "solution": "/**\n/**\n Given n positive integers representing the count of each number from 1 to n, find the maximum sum of the mode (most frequent element) for all prefixes of a sequence constructed from these numbers. The mode is the largest number among the most frequent elements in a sequence.\n*/\n * Given n positive integers representing the count of each number from 1 to n, \n * find the maximum sum of the mode (most frequent element) for all prefixes of \n * a sequence constructed from these numbers. The mode is the largest number \n * among the most frequent elements in a sequence.\n * For example:\n *   maxModeSum(3, [1, 2, 3])\n *   A sequence that reaches its maximum value is [3, 2, 3, 1, 2, 2], and the sum is 17.\n */\nfunction maxModeSum(n, counts)\n\n{\n  let ans = 0;\n  let mx = 0;\n  let f = new Array(100000).fill(0); // Initialize the array with zeroes\n\n  for (let i = 0; i <= n; ++i) {\n    f[i] = 0;\n  }\n\n  for (let i = n; i > 0; --i) {\n    while (mx < counts[i - 1]) {\n      mx++;\n      f[mx] = f[mx - 1] + i;\n    }\n    ans += f[counts[i - 1]];\n  }\n  return ans;\n}"}
{"task_id": "MBPP_JS/classify_integer", "prompt": "def classify_integer(...) :\n    \"\"\"\n    Classify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until \nthe class is determined.\n\nParameters:\n- x (string): The integer to be classified as a string.\n\nReturns:\nint: The class to which the integer x belongs.\n    \"\"\"", "entry_point": "classify_integer", "test": "def check(candidate):\n    console.assert(classify_integer(\"24\") === 6)\n    console.assert(classify_integer(\"39\") === 3)\n    console.assert(classify_integer(\"123456789\") === 9)\n    console.assert(classify_integer(\"123456789012345678901234567890\") === 9)\n    console.assert(classify_integer(\"12345\") === 6)\n    console.assert(classify_integer(\"999999999\") === 9)\ncheck(classify_integer)\n", "given_tests": ["console.assert(classify_integer(\"24\") === 6)"], "solution": "function classify_integer(x)\n/**\n Classify the integer x based on the following method:\n If x is a single-digit number, x belongs to its own class.\n Otherwise, sum the digits of x, get a new x, and iterate until\n the class is determined.\n \n Parameters:\n - x (string): The integer to be classified as a string.\n \n Returns:\n int: The class to which the integer x belongs.\n*/\n{\n    let n = 0;\n    for (let i = 0; i < x.length; i++) {\n        n += parseInt(x[i], 10);\n    }\n    while (n > 9) {\n        let t = n;\n        let a = 0;\n        while (t) {\n            a += t % 10;\n            t = Math.floor(t / 10);\n        }\n        n = a;\n    }\n    return n;\n}"}
